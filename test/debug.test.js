// Generated by CoffeeScript 2.7.0
// debug.test.coffee
var Class1, Class2, allNumbers, double, quadruple;

import test from 'ava';

import {
  haltOnError,
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  undef,
  pass,
  arrayToBlock,
  isNumber,
  isArray,
  spaces
} from '@jdeighan/base-utils/utils';

import {
  toTAML
} from '@jdeighan/base-utils/taml';

import {
  getPrefix
} from '@jdeighan/base-utils/prefix';

import {
  LOG,
  LOGVALUE,
  utReset,
  utGetLog
} from '@jdeighan/base-utils/log';

import {
  setDebugging,
  getType,
  dumpDebugLoggers,
  dbgEnter,
  dbgReturn,
  dbgReturnVal,
  dbgYield,
  dbgYieldFrom,
  dbgResume,
  dbg,
  dbgReset,
  dbgGetLog
} from '@jdeighan/base-utils/debug';

haltOnError(false);

// ---------------------------------------------------------------------------
test("line 27", (t) => {
  setDebugging("myfunc");
  return t.deepEqual(getType("something"), ["string", undef]);
});

test("line 33", (t) => {
  setDebugging("myfunc");
  return t.deepEqual(getType("enter myfunc"), ["enter", "myfunc"]);
});

test("line 39", (t) => {
  setDebugging("myfunc");
  return t.deepEqual(getType("return from X"), ["returnFrom", 'X']);
});

// ---------------------------------------------------------------------------
double = (x) => {
  var result;
  dbgEnter("double", x);
  assert(isNumber(x), "not a number");
  dbg("inside double");
  result = 2 * x;
  dbgReturnVal("double", result);
  return result;
};

quadruple = (x) => {
  var result;
  dbgEnter("quadruple", x);
  dbg("inside quadruple");
  result = 2 * double(x);
  dbgReturnVal("quadruple", result);
  return result;
};

// ---------------------------------------------------------------------------
test("line 64", (t) => {
  var result;
  utReset();
  result = quadruple(3);
  return t.is(result, 12);
});

// ---------------------------------------------------------------------------
test("line 72", (t) => {
  var result;
  utReset();
  setDebugging('double');
  result = quadruple(3);
  return t.is(result, 12);
});

// ---------------------------------------------------------------------------
test("line 81", (t) => {
  var result;
  utReset();
  setDebugging('double');
  result = quadruple(3);
  return t.is(utGetLog(), `enter double 3
│   inside double
└─> return 6 from double`);
});

// ---------------------------------------------------------------------------
test("line 94", (t) => {
  var result;
  utReset();
  setDebugging('double quadruple');
  result = quadruple(3);
  t.is(result, 12);
  return t.is(utGetLog(), `enter quadruple 3
│   inside quadruple
│   enter double 3
│   │   inside double
│   └─> return 6 from double
└─> return 12 from quadruple`);
});

// ---------------------------------------------------------------------------
test("line 111", (t) => {
  var result;
  utReset();
  setDebugging('double', 'quadruple');
  result = quadruple(3);
  t.is(result, 12);
  return t.is(utGetLog(), `enter quadruple 3
│   inside quadruple
│   enter double 3
│   │   inside double
│   └─> return 6 from double
└─> return 12 from quadruple`);
});

// ---------------------------------------------------------------------------
Class1 = class Class1 {
  constructor() {
    this.lStrings = [];
  }

  add(str) {
    dbgEnter("Class1.add", str);
    this.lStrings.push(str);
    dbgReturn("Class1.add");
  }

};

Class2 = class Class2 {
  constructor() {
    this.lStrings = [];
  }

  add(str) {
    dbgEnter("Class2.add", str);
    this.lStrings.push(str);
    dbgReturn("Class2.add");
  }

};

// ---------------------------------------------------------------------------
test("line 148", (t) => {
  utReset();
  setDebugging('Class1.add Class2.add');
  new Class1().add('abc');
  new Class2().add('def');
  return t.is(utGetLog(), `enter Class1.add 'abc'
└─> return from Class1.add
enter Class2.add 'def'
└─> return from Class2.add`);
});

// ---------------------------------------------------------------------------
test("line 164", (t) => {
  utReset();
  setDebugging('Class2.add');
  new Class1().add('abc');
  new Class2().add('def');
  return t.is(utGetLog(), `enter Class2.add 'def'
└─> return from Class2.add`);
});

// ---------------------------------------------------------------------------
test("line 178", (t) => {
  var result;
  utReset();
  setDebugging('double quadruple');
  result = double(quadruple(3));
  t.is(result, 24);
  return t.is(utGetLog(), `enter quadruple 3
│   inside quadruple
│   enter double 3
│   │   inside double
│   └─> return 6 from double
└─> return 12 from quadruple
enter double 12
│   inside double
└─> return 24 from double`);
});

// ---------------------------------------------------------------------------
// Test using generators
allNumbers = function*(lItems) {
  var item, j, len;
  dbgEnter("allNumbers");
  for (j = 0, len = lItems.length; j < len; j++) {
    item = lItems[j];
    if (isNumber(item)) {
      dbgYield("allNumbers", item);
      yield item;
      dbgResume("allNumbers");
    } else if (isArray(item)) {
      dbgYieldFrom("allNumbers");
      yield* allNumbers(item);
      dbgResume("allNumbers");
    }
  }
  dbgReturn("allNumbers");
};

test("line 214", (t) => {
  var i, lItems, ref, total;
  lItems = ['a', 2, ['b', 3], 5];
  total = 0;
  ref = allNumbers(lItems);
  for (i of ref) {
    total += i;
  }
  return t.is(total, 10);
});

// ---------------------------------------------------------------------------
// Test custom loggers
test("line 224", (t) => {
  var result;
  utReset();
  setDebugging('double quadruple', {
    // --- on dbgEnter('<func>'), just log the function name
    enter: function(funcName, lObjects, level) {
      LOG(getPrefix(level, 'plain') + funcName);
      return true;
    },
    // --- on dbgReturn('<func>'), don't log anything at all
    returnFrom: function(funcName, level) {
      return true;
    },
    // --- on dbgReturnVal('<func>', <val>), don't log anything at all
    returnVal: function(funcName, val, level) {
      return true;
    }
  });
  result = double(quadruple(3));
  t.is(result, 24);
  return t.is(utGetLog(), `quadruple
│   inside quadruple
│   double
│   │   inside double
double
│   inside double`);
});

// ---------------------------------------------------------------------------
(function() {
  var A, B, C, D, lOutput, main, output;
  lOutput = undef;
  output = function(str) {
    return lOutput.push(str);
  };
  main = function() {
    A();
  };
  A = function() {
    var ref, x;
    dbgEnter("A");
    C();
    ref = B();
    for (x of ref) {
      output(x);
      C();
    }
    dbgReturn("A");
  };
  B = function*() {
    dbgEnter("B");
    output(13);
    dbgYield("B", 5);
    yield 5;
    dbgResume("B");
    C();
    dbgYieldFrom("B");
    yield* D();
    dbgResume("B");
    dbgReturn("B");
  };
  C = function() {
    dbgEnter("C");
    output('here');
    dbg("here");
    dbg("x", 9);
    dbgReturn("C");
  };
  D = function*() {
    dbgEnter("D");
    dbgYield("D", 1);
    yield 1;
    dbgResume("D");
    dbgYield("D", 2);
    yield 2;
    dbgResume("D");
    dbgReturn("D");
  };
  test("line 307", (t) => {
    lOutput = [];
    utReset();
    main();
    t.is(arrayToBlock(lOutput), `here
13
5
here
here
1
here
2
here`);
    return t.is(utGetLog(), undef);
  });
  // --- Try with various settings of setDebugging()
  test("line 326", (t) => {
    lOutput = [];
    utReset();
    setDebugging("C");
    main();
    // --- C should be called 5 times
    return t.is(utGetLog(), `enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C`);
  });
  test("line 357", (t) => {
    lOutput = [];
    utReset();
    setDebugging("D");
    main();
    // --- D should be called once, yielding twice
    return t.is(utGetLog(), `enter D
├── yield 1
├── yield 2
└─> return from D`);
  });
  test("line 372", (t) => {
    lOutput = [];
    utReset();
    setDebugging("C D");
    main();
    // --- D should be called once, yielding twice
    return t.is(utGetLog(), `enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C
enter C
│   here
│   x = 9
└─> return from C
enter D
├── yield 1
│   enter C
│   │   here
│   │   x = 9
│   └─> return from C
├── yield 2
│   enter C
│   │   here
│   │   x = 9
│   └─> return from C
└─> return from D`);
  });
  return test("line 407", (t) => {
    lOutput = [];
    utReset();
    setDebugging(true);
    main();
    // --- debug all
    return t.is(utGetLog(), `enter A
│   enter C
│   │   here
│   │   x = 9
│   └─> return from C
│   enter B
│   ├── yield 5
│   │   enter C
│   │   │   here
│   │   │   x = 9
│   │   └─> return from C
│   │   enter C
│   │   │   here
│   │   │   x = 9
│   │   └─> return from C
│   ├── yieldFrom
│   │   enter D
│   │   ├── yield 1
│   │   │   enter C
│   │   │   │   here
│   │   │   │   x = 9
│   │   │   └─> return from C
│   │   ├── yield 2
│   │   │   enter C
│   │   │   │   here
│   │   │   │   x = 9
│   │   │   └─> return from C
│   │   └─> return from D
│   └─> return from B
└─> return from A`);
  });
})();

// ---------------------------------------------------------------------------
// --- We want to separate debug and normal logging
(function() {
  var A, dbgOutput, hCustomLoggers, logOutput, main;
  utReset(); // sets a custom logger for calls to LOG, LOGVALUE
  dbgReset(); // sets a custom logger for calls to debug functions
  main = function() {
    dbgEnter('main');
    LOG('in main()');
    A();
    dbgReturn('main');
  };
  A = function() {
    dbgEnter('A');
    LOG('in A()');
    dbgReturn('A');
  };
  hCustomLoggers = {
    enter: function(funcName, lVals, level) {
      return LOG(`ENTERING ${funcName}`);
    }
  };
  setDebugging('A', hCustomLoggers);
  main();
  dbgOutput = dbgGetLog();
  logOutput = utGetLog();
  test("line 489", (t) => {
    return t.is(logOutput, `in main()
in A()`);
  });
  return test("line 494", (t) => {
    return t.is(dbgOutput, `ENTERING A
└─> return from A`);
  });
})();
