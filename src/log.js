// Generated by CoffeeScript 2.7.0
// log.coffee
var doDebugLogging, lUTLog, loaded, putstr, threeSpaces;

import {
  strict as assert
} from 'node:assert';

import {
  pass,
  undef,
  defined,
  notdefined,
  deepCopy,
  hEsc,
  escapeStr,
  OL,
  toTAML,
  blockToArray,
  arrayToBlock,
  isNumber,
  isInteger,
  isString,
  isHash,
  isFunction,
  nonEmpty,
  hEscNoNL,
  jsType,
  hasChar,
  quoted
} from '@jdeighan/exceptions/utils';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

// --- This logger only ever gets passed a single string argument
putstr = undef;

export var logWidth = 42;

export var sep_dash = '-'.repeat(logWidth);

export var sep_eq = '='.repeat(logWidth);

export var stringify = undef;

doDebugLogging = false;

threeSpaces = '   ';

// ---------------------------------------------------------------------------
export var setLogWidth = (w) => {
  logWidth = w;
  sep_dash = '-'.repeat(logWidth);
  sep_eq = '='.repeat(logWidth);
};

// ---------------------------------------------------------------------------
export var resetLogWidth = () => {
  setLogWidth(42);
};

// ---------------------------------------------------------------------------
export var debugLogging = (flag = true) => {
  doDebugLogging = flag;
  if (doDebugLogging) {
    console.log(`doDebugLogging = ${flag}`);
  }
};

// ---------------------------------------------------------------------------
export var setStringifier = (func) => {
  var orgStringifier;
  orgStringifier = stringify;
  assert(isFunction(func), "setStringifier() arg is not a function");
  stringify = func;
  return orgStringifier;
};

// ---------------------------------------------------------------------------
export var resetStringifier = () => {
  return setStringifier(orderedStringify);
};

// ---------------------------------------------------------------------------
export var setLogger = (func) => {
  var orgLogger;
  assert(isFunction(func), "setLogger() arg is not a function");
  orgLogger = putstr;
  putstr = func;
  return orgLogger;
};

// ---------------------------------------------------------------------------
export var resetLogger = () => {
  return setLogger(console.log);
};

// ---------------------------------------------------------------------------
export var tamlStringify = (obj, escape = false) => {
  return toTAML(obj, {
    useTabs: false,
    sortKeys: false,
    escape
  });
};

// ---------------------------------------------------------------------------
export var orderedStringify = (obj, escape = false) => {
  return toTAML(obj, {
    useTabs: false,
    sortKeys: true,
    escape
  });
};

// ---------------------------------------------------------------------------
export var LOG = (str = "", prefix = "") => {
  if (doDebugLogging) {
    console.log(`CALL LOG(${OL(str)}), prefix=${OL(prefix)}`);
    if (putstr !== console.log) {
      console.log("   - use custom logger");
    }
  }
  putstr(`${prefix}${str}`);
  return true; // to allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var LOGVALUE = (label, value, prefix = "", itemPrefix = undef) => {
  var baselen, i, len, ref, str, str1, str2, str3, subtype, type;
  assert(nonEmpty(label), "label is empty");
  if (notdefined(itemPrefix)) {
    itemPrefix = prefix;
  }
  if (doDebugLogging) {
    str1 = OL(label);
    str2 = OL(value);
    str3 = OL(prefix);
    console.log(`CALL LOGITEM(${str1}, ${str2}), prefix=${str3}`);
  }
  [type, subtype] = jsType(value);
  baselen = prefix.length + label.length;
  switch (type) {
    case undef:
      putstr(`${prefix}${label} = ${subtype}`);
      break;
    case 'string':
      if (subtype === 'empty') {
        putstr(`${prefix}${label} = ''`);
      } else {
        str = quoted(value, 'escape');
        if (baselen + str.length + 3 <= logWidth) {
          putstr(`${prefix}${label} = ${str}`);
        } else {
          // --- escape, but not newlines
          str = quoted(value, 'escapeNoNL');
          putstr(`${prefix}${label} = ${str}`);
        }
      }
      break;
    case 'number':
      putstr(`${prefix}${label} = ${value}`);
      break;
    case 'boolean':
      putstr(`${prefix}${label} = ${subtype}`);
      break;
    case 'hash':
    case 'array':
      str = toTAML(value, {
        sortKeys: true
      });
      putstr(`${prefix}${label} =`);
      ref = blockToArray(str);
      for (i = 0, len = ref.length; i < len; i++) {
        str = ref[i];
        putstr(`${itemPrefix}${str}`);
      }
      break;
    case 'regexp':
      putstr(`${prefix}${label} = <regexp>`);
      break;
    case 'function':
      putstr(`${prefix}${label} = <function>`);
      break;
    case 'object':
      putstr(`${prefix}${label} = <object>`);
  }
  return true;
};

// ---------------------------------------------------------------------------
// simple redirect to an array - useful in unit tests
lUTLog = [];

export var utReset = () => {
  lUTLog = [];
  return setLogger((str) => {
    return lUTLog.push(str);
  });
};

export var utGetLog = () => {
  return arrayToBlock(lUTLog, hEscNoNL);
};

if (!loaded) {
  setStringifier(orderedStringify);
  resetLogger();
}

loaded = true;
