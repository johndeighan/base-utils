// Generated by CoffeeScript 2.7.0
// log.coffee
var doDebugLogging, lUTLog, loaded, putstr, threeSpaces;

import {
  strict as assert
} from 'node:assert';

import {
  pass,
  undef,
  defined,
  notdefined,
  deepCopy,
  hEsc,
  escapeStr,
  OL,
  hasMethod,
  blockToArray,
  arrayToBlock,
  isNumber,
  isInteger,
  isString,
  isHash,
  isFunction,
  isBoolean,
  nonEmpty,
  hEscNoNL,
  jsType,
  hasChar,
  quoted
} from '@jdeighan/exceptions/utils';

import {
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

// --- This logger only ever gets passed a single string argument
putstr = undef;

export var logWidth = 42;

export var sep_dash = '-'.repeat(logWidth);

export var sep_eq = '='.repeat(logWidth);

export var stringify = undef;

doDebugLogging = false;

threeSpaces = '   ';

// ---------------------------------------------------------------------------
export var setLogWidth = (w) => {
  logWidth = w;
  sep_dash = '-'.repeat(logWidth);
  sep_eq = '='.repeat(logWidth);
};

// ---------------------------------------------------------------------------
export var resetLogWidth = () => {
  setLogWidth(42);
};

// ---------------------------------------------------------------------------
export var debugLogging = (flag = true) => {
  doDebugLogging = flag;
  if (doDebugLogging) {
    console.log(`doDebugLogging = ${flag}`);
  }
};

// ---------------------------------------------------------------------------
export var setStringifier = (func) => {
  var orgStringifier;
  orgStringifier = stringify;
  assert(isFunction(func), "setStringifier() arg is not a function");
  stringify = func;
  return orgStringifier;
};

// ---------------------------------------------------------------------------
export var resetStringifier = () => {
  return setStringifier(orderedStringify);
};

// ---------------------------------------------------------------------------
export var setLogger = (func) => {
  var orgLogger;
  assert(isFunction(func), "setLogger() arg is not a function");
  orgLogger = putstr;
  putstr = func;
  return orgLogger;
};

// ---------------------------------------------------------------------------
export var resetLogger = () => {
  return setLogger(console.log);
};

// ---------------------------------------------------------------------------
export var tamlStringify = (obj, escape = false) => {
  return toTAML(obj, {
    useTabs: false,
    sortKeys: false,
    escape
  });
};

// ---------------------------------------------------------------------------
export var orderedStringify = (obj, escape = false) => {
  return toTAML(obj, {
    useTabs: false,
    sortKeys: true,
    escape
  });
};

// ---------------------------------------------------------------------------
export var LOG = (str = "", prefix = "") => {
  if (doDebugLogging) {
    console.log(`CALL LOG(${OL(str)}), prefix=${OL(prefix)}`);
    if (putstr !== console.log) {
      console.log("   - use custom logger");
    }
  }
  putstr(`${prefix}${str}`);
  return true; // to allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var LOGVALUE = (label, value, prefix = "", itemPrefix = undef) => {
  var i, j, len, len1, len2, line, ref, ref1, str, str1, str2, str3, subtype, type;
  if (doDebugLogging) {
    str1 = OL(label);
    str2 = OL(value);
    str3 = OL(prefix);
    console.log(`CALL LOGITEM(${str1}, ${str2}), prefix=${str3}`);
  }
  assert(nonEmpty(label), "label is empty");
  // --- Handle some simple cases
  if (value === undef) {
    putstr(`${prefix}${label} = undef`);
    return true;
  } else if (value === null) {
    putstr(`${prefix}${label} = null`);
    return true;
  } else if (isBoolean(value)) {
    if (value) {
      putstr(`${prefix}${label} = true`);
    } else {
      putstr(`${prefix}${label} = false`);
    }
    return true;
  } else if (isNumber(value)) {
    putstr(`${prefix}${label} = ${value}`);
    return true;
  }
  // --- Try OL() - if it's short enough, use that
  str = `${prefix}${label} = ${OL(value)}`;
  if (str.length <= logWidth) {
    putstr(str);
    return true;
  }
  [type, subtype] = jsType(value);
  switch (type) {
    case 'string':
      if (subtype === 'empty') {
        putstr(`${prefix}${label} = ''`);
      } else {
        str = quoted(value, 'escape');
        len = prefix.length + label.length + str.length + 3;
        if (len <= logWidth) {
          putstr(`${prefix}${label} = ${str}`);
        } else {
          // --- escape, but not newlines
          str = quoted(value, 'escapeNoNL');
          putstr(`${prefix}${label} = ${str}`);
        }
      }
      break;
    case 'hash':
    case 'array':
      str = toTAML(value, {
        sortKeys: true
      });
      putstr(`${prefix}${label} =`);
      if (notdefined(itemPrefix)) {
        itemPrefix = prefix;
      }
      ref = blockToArray(str);
      for (i = 0, len1 = ref.length; i < len1; i++) {
        str = ref[i];
        putstr(`${itemPrefix}${str}`);
      }
      break;
    case 'regexp':
      putstr(`${prefix}${label} = <regexp>`);
      break;
    case 'function':
      putstr(`${prefix}${label} = <function>`);
      break;
    case 'object':
      if (hasMethod(value, 'toLogString')) {
        str = value.toLogString();
      } else {
        str = toTAML(value);
      }
      if (hasChar(str, "\n")) {
        putstr(`${prefix}${label} =`);
        if (notdefined(itemPrefix)) {
          itemPrefix = prefix;
        }
        ref1 = blockToArray(str);
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          line = ref1[j];
          putstr(`${itemPrefix}${line}`);
        }
      } else {
        putstr(`${prefix}${label} = ${str}`);
      }
  }
  return true;
};

// ---------------------------------------------------------------------------
// simple redirect to an array - useful in unit tests
lUTLog = [];

export var utReset = () => {
  lUTLog = [];
  return setLogger((str) => {
    return lUTLog.push(str);
  });
};

export var utGetLog = () => {
  return arrayToBlock(lUTLog);
};

if (!loaded) {
  setStringifier(orderedStringify);
  resetLogger();
}

loaded = true;
