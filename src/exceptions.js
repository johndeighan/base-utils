// Generated by CoffeeScript 2.7.0
// exceptions.coffee
const undef = void 0;
var LLOG, doHaltOnError, doLog, getCallers, lExceptionLog,
  indexOf = [].indexOf;

doHaltOnError = true;

doLog = true;

// ---------------------------------------------------------------------------
export var suppressExceptionLogging = function(flag = true) {
  doLog = !flag;
};

// ---------------------------------------------------------------------------
export var haltOnError = function(flag = true) {
  var save;
  // --- return existing setting
  save = doHaltOnError;
  doHaltOnError = flag;
  return save;
};

// ---------------------------------------------------------------------------
// simple redirect to an array - useful in unit tests
lExceptionLog = undef;

export var exReset = () => {
  lExceptionLog = [];
};

export var exGetLog = () => {
  var result;
  result = lExceptionLog.join("\n");
  lExceptionLog = undef;
  return result;
};

// ---------------------------------------------------------------------------
LLOG = function(str) {
  if (lExceptionLog) {
    return lExceptionLog.push(str);
  } else if (doLog) {
    return console.log(str);
  }
};

// ---------------------------------------------------------------------------
getCallers = function(stackTrace, lExclude = []) {
  var _, caller, iter, lCallers, lMatches;
  iter = stackTrace.matchAll(/at\s+(?:async\s+)?([^\s(]+)/g);
  if (!iter) {
    return ["<unknown>"];
  }
  lCallers = [];
  for (lMatches of iter) {
    [_, caller] = lMatches;
    if (caller.indexOf('file://') === 0) {
      break;
    }
    if (indexOf.call(lExclude, caller) < 0) {
      lCallers.push(caller);
    }
  }
  return lCallers;
};

// ---------------------------------------------------------------------------
//   assert - mimic nodejs's assert
//   return true so we can use it in boolean expressions
export var assert = function(cond, msg) {
  var caller, i, lCallers, len, stackTrace;
  if (!cond) {
    stackTrace = new Error().stack;
    lCallers = getCallers(stackTrace, ['assert']);
    LLOG('-------------------------');
    LLOG('JavaScript CALL STACK:');
    for (i = 0, len = lCallers.length; i < len; i++) {
      caller = lCallers[i];
      LLOG(`   ${caller}`);
    }
    LLOG('-------------------------');
    LLOG(`ERROR: ${msg} (in ${lCallers[0]}())`);
    croak(msg);
  }
  return true;
};

// ---------------------------------------------------------------------------
//   croak - throws an error after possibly printing useful info
//           err can be a string or an Error object
export var croak = function(err, label = undef, obj = undef) {
  var curmsg, newmsg;
  if ((typeof err === 'string') || (err instanceof String)) {
    curmsg = err;
  } else {
    curmsg = err.message;
  }
  if ((label === undef) || (label === null) || (label === '')) {
    newmsg = `ERROR (croak): ${curmsg}`;
  } else {
    newmsg = `ERROR (croak): ${curmsg}
${label}:
${JSON.stringify(obj)}`;
  }
  if (doHaltOnError) {
    LLOG(newmsg);
    return process.exit();
  } else {
    // --- re-throw the error
    throw new Error(newmsg);
  }
};
