// Generated by CoffeeScript 2.7.0
// stack.coffee
var internalDebugging;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  notdefined,
  OL,
  deepCopy,
  warn,
  oneof,
  spaces,
  isString,
  isArray,
  isBoolean,
  isEmpty,
  nonEmpty
} from '@jdeighan/base-utils/utils';

import {
  LOG
} from '@jdeighan/base-utils/log';

import {
  getPrefix
} from '@jdeighan/base-utils/prefix';

internalDebugging = false;

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  internalDebugging = flag;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor(debugFlag = false) {
    // --- Items on stack have keys:
    //        funcName
    //        lArgs
    //        doLog
    //        isYielded
    debugStack(debugFlag);
    this.lStack = [];
  }

  // ........................................................................
  dbg(str) {
    console.log(this.indent() + str);
  }

  // ........................................................................
  reset() {
    this.lStack = [];
    if (internalDebugging) {
      this.dbg("RESET STACK");
    }
  }

  // ........................................................................
  indent() {
    // --- Only used in debugging the stack
    return getPrefix(this.lStack.length);
  }

  // ........................................................................
  stackErr(cond, msg) {
    if (!cond) {
      warn(`${msg}\n${this.dump()}`);
    }
  }

  // ........................................................................
  // ........................................................................
  enter(funcName, lArgs = [], doLog = false) {
    var nArgs;
    assert(isArray(lArgs), "not an array");
    if (internalDebugging) {
      nArgs = lArgs.length;
      if (nArgs === 0) {
        this.dbg(`[--> ENTER ${funcName}]`);
      } else {
        this.dbg(`[--> ENTER ${funcName} ${nArgs} args]`);
      }
    }
    this.lStack.push({
      funcName,
      lArgs: deepCopy(lArgs),
      doLog,
      isYielded: false
    });
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  returnFrom(funcName, lVals = []) {
    var nVals, rec;
    assert(isArray(lVals), "not an array");
    rec = this.currentFuncRec();
    this.stackErr(funcName === rec.funcName, `returnFrom('${funcName}') but current func is ${rec.funcName}`);
    this.stackErr(!this.TOS.isYielded, `returnFrom('${funcName}') but ${this.TOS().funcName} at TOS is yielded`);
    if (internalDebugging) {
      nVals = this.lVals.length;
      if (nVals === 0) {
        this.dbg(`[<-- RETURN FROM ${funcName}]`);
      } else {
        this.dbg(`[<-- RETURN FROM ${funcName} ${nVals} vals]`);
      }
    }
    this.lStack.pop();
  }

  // ........................................................................
  yield(funcName, lVals = []) {
    var nVals, rec;
    assert(isString(funcName), "not a string");
    assert(isArray(lVals), "not an array");
    if (internalDebugging) {
      nVals = this.lVals.length;
      if (nVals === 0) {
        this.dbg("[--> YIELD]");
      } else {
        this.dbg(`[--> YIELD ${funcName} ${nVals} vals]`);
      }
    }
    rec = this.currentFuncRec();
    this.stackErr(funcName === rec.funcName, `yield ${funcName}, but current func is ${rec.funcName}`);
    rec.isYielded = true;
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  resume(funcName) {
    var rec;
    rec = this.TOS();
    this.stackErr(rec.isYielded, `resume('${funcName}') but ${funcName} is not yielded`);
    rec.isYielded = false;
    if (internalDebugging) {
      this.dbg(`[<-- RESUME ${funcName}]`);
    }
  }

  // ........................................................................
  // ........................................................................
  isLogging() {
    var rec;
    rec = this.currentFuncRec();
    if (defined(rec)) {
      return rec.doLog;
    } else {
      return false;
    }
  }

  // ........................................................................
  getIndentLevel() {
    var i, item, len, level, ref;
    level = 0;
    ref = this.lStack;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item.doLog) {
        level += 1;
      }
    }
    return level;
  }

  // ........................................................................
  currentFunc() {
    var rec;
    rec = this.currentFuncRec();
    if (defined(rec)) {
      return rec.funcName;
    } else {
      return 'main';
    }
  }

  // ........................................................................
  currentFuncRec() {
    return this.lStack.findLast(function(rec) {
      return !rec.isYielded;
    });
  }

  // ........................................................................
  TOS() {
    if (this.lStack.length === 0) {
      return undef;
    } else {
      return this.lStack[this.lStack.length - 1];
    }
  }

  // ........................................................................
  size() {
    return this.lStack.length;
  }

  // ........................................................................
  isActive(funcName) {
    var h, i, len, ref;
    ref = this.lStack;
    for (i = 0, len = ref.length; i < len; i++) {
      h = ref[i];
      if (h.funcName === funcName) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  dump() {
    var lLines, pos;
    lLines = ['-- CALL STACK --'];
    if (this.lStack.length === 0) {
      lLines.push("\t<EMPTY>");
    } else {
      pos = this.lStack.length;
      while (pos > 0) {
        pos -= 1;
        lLines.push("\t" + this.callStr(this.lStack[pos]));
      }
    }
    return lLines.join("\n");
  }

  // ........................................................................
  callStr(item) {
    var sym;
    sym = item.doLog ? 'L' : '-';
    if (item.isYielded) {
      return `${sym} ${item.funcName}*`;
    } else {
      return `${sym} ${item.funcName}`;
    }
  }

};
