// Generated by CoffeeScript 2.7.0
// stack.coffee
var doDebugStack;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  OL,
  deepCopy,
  isArray,
  isBoolean,
  isEmpty,
  nonEmpty
} from '@jdeighan/exceptions/utils';

import {
  LOG
} from '@jdeighan/exceptions/log';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

doDebugStack = false;

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  doDebugStack = flag;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor() {
    this.lStack = [];
  }

  // ........................................................................
  reset() {
    if (doDebugStack) {
      console.log("RESET STACK");
    }
    this.lStack = [];
  }

  // ........................................................................
  indent() {
    // --- Only used in debugging the stack
    return getPrefix(this.lStack.length);
  }

  // ........................................................................
  enter(funcName, objName, lArgs = [], isLogged) {
    var fullName;
    // --- funcName might be <object>.<method>
    assert(isArray(lArgs), "bad lArgs");
    assert(isBoolean(isLogged), "bad isLogged");
    if (doDebugStack) {
      console.log(this.indent() + `[--> ENTER ${funcName}]`);
    }
    if (nonEmpty(objName)) {
      fullName = `${objName}.${funcName}`;
    } else {
      fullName = funcName;
    }
    this.lStack.push({
      fullName,
      funcName,
      objName,
      isLogged,
      lArgs: deepCopy(lArgs)
    });
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  returnFrom(funcName, objName) {
    var fullName, fullReturnName, isLogged;
    if (objName) {
      fullReturnName = `${objName}.${funcName}`;
    } else {
      fullReturnName = funcName;
    }
    if (this.lStack.length === 0) {
      LOG(`ERROR: returnFrom('${fullReturnName}') but stack is empty`);
      return;
    }
    ({fullName, isLogged} = this.lStack.pop());
    if (doDebugStack) {
      console.log(this.indent() + `[<-- BACK ${fullReturnName}]`);
    }
    if (fullName !== fullReturnName) {
      LOG(`ERROR: returnFrom('${fullReturnName}') but TOS is ${fullName}`);
      return;
    }
  }

  // ........................................................................
  isLogging() {
    if (this.lStack.length === 0) {
      return false;
    } else {
      return this.lStack[this.lStack.length - 1].isLogged;
    }
  }

  // ........................................................................
  getLevel() {
    var item, j, len, level, ref;
    level = 0;
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isLogged) {
        level += 1;
      }
    }
    return level;
  }

  // ........................................................................
  curFunc() {
    var h;
    if (this.lStack.length === 0) {
      return ['main', undef];
    } else {
      h = this.TOS();
      if (defined(h)) {
        return [h.funcName, h.objName];
      } else {
        return [undef, undef];
      }
    }
  }

  // ........................................................................
  TOS() {
    if (this.lStack.length === 0) {
      return undef;
    } else {
      return this.lStack[this.lStack.length - 1];
    }
  }

  // ........................................................................
  isActive(funcName, objName) {
    var h, j, len, ref;
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      h = ref[j];
      if ((h.funcName === funcName) && (h.objName === objName)) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  dump() {
    var i, item, j, lLines, len, ref;
    lLines = ['CALL STACK'];
    if (this.lStack.length === 0) {
      lLines.push("   <EMPTY>");
    } else {
      ref = this.lStack;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        lLines.push("   " + this.callStr(i, item));
      }
    }
    return lLines.join("\n");
  }

  // ........................................................................
  callStr(i, item) {
    var arg, j, len, ref, str, sym;
    sym = item.isLogged ? '*' : '-';
    str = `${i}: ${sym}${item.fullName}`;
    ref = item.lArgs;
    for (j = 0, len = ref.length; j < len; j++) {
      arg = ref[j];
      str += ` ${OL(arg)}`;
    }
    return str;
  }

  // ........................................................................
  sdump(label = 'CALL STACK') {
    var item, j, lFuncNames, len, ref;
    lFuncNames = [];
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isLogged) {
        lFuncNames.push('*' + item.fullName);
      } else {
        lFuncNames.push(item.fullName);
      }
    }
    if (this.lStack.length === 0) {
      return `${label} <EMPTY>`;
    } else {
      return `${label} ${lFuncNames.join(' ')}`;
    }
  }

};
