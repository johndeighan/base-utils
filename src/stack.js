// Generated by CoffeeScript 2.7.0
// stack.coffee
var internalDebugging;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  OL,
  deepCopy,
  isArray,
  isBoolean,
  isEmpty,
  nonEmpty
} from '@jdeighan/exceptions/utils';

import {
  LOG
} from '@jdeighan/exceptions/log';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

internalDebugging = false;

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  internalDebugging = flag;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor() {
    this.lStack = [];
  }

  // ........................................................................
  reset() {
    if (internalDebugging) {
      console.log("RESET STACK");
    }
    this.lStack = [];
  }

  // ........................................................................
  indent() {
    // --- Only used in debugging the stack
    return getPrefix(this.lStack.length);
  }

  // ........................................................................
  enter(funcName, lArgs, isLogged) {
    assert(isArray(lArgs), "bad lArgs");
    assert(isBoolean(isLogged), "bad isLogged");
    if (internalDebugging) {
      console.log(this.indent() + `[--> ENTER ${funcName}]`);
    }
    this.lStack.push({
      funcName,
      lArgs: deepCopy(lArgs),
      isLogged
    });
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  returnFrom(funcName) {
    var isLogged;
    if (this.lStack.length === 0) {
      LOG(`ERROR: returnFrom('${funcName}') but stack is empty`);
      return;
    }
    if (this.TOS().funcName !== funcName) {
      LOG(`ERROR: returnFrom('${funcName}') but TOS is ${this.TOS().funcName}`);
      return;
    }
    ({funcName, isLogged} = this.lStack.pop());
    if (internalDebugging) {
      console.log(this.indent() + `[<-- RETURN FROM ${funcName}]`);
    }
  }

  // ........................................................................
  yield(funcName, lArgs = [], isLogged) {
    assert(isArray(lArgs), "bad lArgs");
    assert(isBoolean(isLogged), "bad isLogged");
    if (internalDebugging) {
      console.log(this.indent() + `[--> YIELD ${funcName}]`);
    }
    this.lStack.push({
      funcName,
      lArgs: deepCopy(lArgs),
      isLogged
    });
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  continue(funcName) {
    var isLogged;
    if (this.lStack.length === 0) {
      LOG(`ERROR: continue('${funcName}') but stack is empty`);
      return;
    }
    if (this.TOS().funcName !== funcName) {
      LOG(`ERROR: continue('${funcName}') but TOS is ${this.TOS().funcName}`);
      return;
    }
    ({funcName, isLogged} = this.lStack.pop());
    if (internalDebugging) {
      console.log(this.indent() + `[<-- CONTINUE ${funcName}]`);
    }
  }

  // ........................................................................
  isLogging() {
    if (this.lStack.length === 0) {
      return false;
    } else {
      return this.TOS().isLogged;
    }
  }

  // ........................................................................
  getLevel() {
    var item, j, len, level, ref;
    level = 0;
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isLogged) {
        level += 1;
      }
    }
    return level;
  }

  // ........................................................................
  curFunc() {
    if (this.lStack.length === 0) {
      return 'main';
    } else {
      return this.TOS().funcName;
    }
  }

  // ........................................................................
  TOS() {
    if (this.lStack.length === 0) {
      return undef;
    } else {
      return this.lStack[this.lStack.length - 1];
    }
  }

  // ........................................................................
  isActive(funcName) {
    var h, j, len, ref;
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      h = ref[j];
      if (h.funcName === funcName) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  dump() {
    var i, item, j, lLines, len, ref;
    lLines = ['CALL STACK'];
    if (this.lStack.length === 0) {
      lLines.push("   <EMPTY>");
    } else {
      ref = this.lStack;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        lLines.push("   " + this.callStr(i, item));
      }
    }
    return lLines.join("\n");
  }

  // ........................................................................
  callStr(i, item) {
    var arg, j, len, ref, str, sym;
    sym = item.isLogged ? '*' : '-';
    str = `${i}: ${sym}${item.funcName}`;
    ref = item.lArgs;
    for (j = 0, len = ref.length; j < len; j++) {
      arg = ref[j];
      str += ` ${OL(arg)}`;
    }
    return str;
  }

  // ........................................................................
  sdump(label = 'CALL STACK') {
    var item, j, lFuncNames, len, ref;
    lFuncNames = [];
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isLogged) {
        lFuncNames.push('*' + item.funcName);
      } else {
        lFuncNames.push(item.funcName);
      }
    }
    if (this.lStack.length === 0) {
      return `${label} <EMPTY>`;
    } else {
      return `${label} ${lFuncNames.join(' ')}`;
    }
  }

};
