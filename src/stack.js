// Generated by CoffeeScript 2.7.0
// stack.coffee
var doThrowOnError, internalDebugging;

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  undef,
  defined,
  notdefined,
  OL,
  deepCopy,
  warn,
  oneof,
  isString,
  isArray,
  isBoolean,
  isEmpty,
  nonEmpty,
  isFunctionName,
  spaces,
  tabs
} from '@jdeighan/base-utils/utils';

import {
  LOG
} from '@jdeighan/base-utils/log';

internalDebugging = false;

doThrowOnError = false;

// ---------------------------------------------------------------------------
export var throwOnError = function(flag = true) {
  var save;
  save = doThrowOnError;
  doThrowOnError = flag;
  return save;
};

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  var save;
  save = internalDebugging;
  internalDebugging = !!flag;
  return save;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor() {
    // --- Items on stack have keys:
    //        funcName
    //        lArgs
    //        caller
    //        doLog
    //        isYielded
    this.reset();
  }

  // ........................................................................
  reset() {
    this.lStack = [];
    this.level = 0;
    this.logLevel = 0;
    if (internalDebugging) {
      this.dbg("RESET STACK");
    }
  }

  // ........................................................................
  // ........................................................................
  enter(funcName, lArgs = [], doLog = false) {
    var nArgs;
    assert(isFunctionName(funcName), "not a function name");
    assert(isArray(lArgs), "not an array");
    this.lStack.push({
      funcName,
      lArgs: deepCopy(lArgs),
      caller: this.currentFuncRec(),
      doLog,
      isYielded: false
    });
    if (internalDebugging) {
      nArgs = lArgs.length;
      if (nArgs === 0) {
        this.dbg(`ENTER ${funcName}`);
      } else {
        this.dbg(`ENTER ${funcName} ${nArgs} args`);
      }
    }
    this.incLevel(doLog);
  }

  // ........................................................................
  returnFrom(funcName) {
    var rec;
    assert(isString(funcName), "not a string");
    rec = this.currentFuncRec();
    this.stackAssert(funcName === rec.funcName, `returnFrom ${funcName} but current func is ${rec.funcName}`);
    this.stackAssert(!this.TOS.isYielded, `returnFrom ${funcName} but ${this.TOS().funcName} at TOS is yielded`);
    this.lStack.pop();
    if (internalDebugging) {
      this.dbg(`RETURN FROM ${funcName}`);
    }
    this.decLevel(rec.doLog);
  }

  // ........................................................................
  returnVal(funcName, val) {
    var rec;
    assert(isString(funcName), "not a string");
    rec = this.currentFuncRec();
    this.stackAssert(funcName === rec.funcName, `returnFrom ${funcName} but current func is ${rec.funcName}`);
    this.stackAssert(!this.TOS.isYielded, `returnFrom ${funcName} but ${this.TOS().funcName} at TOS is yielded`);
    this.lStack.pop();
    if (internalDebugging) {
      this.dbg(`RETURN FROM ${funcName} ${OL(val)}`);
    }
    this.decLevel(rec.doLog);
  }

  // ........................................................................
  yield(...lArgs) {
    var funcName, rec, val;
    assert(lArgs.length === 2, `Bad # args: ${lArgs.length}`);
    [funcName, val] = lArgs;
    rec = this.currentFuncRec();
    rec.isYielded = true;
    if (internalDebugging) {
      this.dbg(`YIELD ${OL(val)} - in ${funcName}`);
    }
  }

  // ........................................................................
  yieldFrom(funcName) {
    var rec;
    rec = this.currentFuncRec();
    rec.isYielded = true;
    if (internalDebugging) {
      this.dbg(`YIELD FROM - in ${funcName}`);
    }
  }

  // ........................................................................
  resume(funcName) {
    var rec;
    rec = this.TOS();
    assert(rec.funcName === funcName, `resume ${funcName} but TOS is ${rec.funcName}`);
    this.stackAssert(rec.isYielded, `resume('${funcName}') but ${funcName} is not yielded`);
    rec.isYielded = false;
    if (internalDebugging) {
      this.dbg(`RESUME ${funcName}`);
    }
  }

  // ........................................................................
  // ........................................................................
  dbg(str) {
    var curFunc;
    curFunc = this.currentFunc() || '<undef>';
    LOG(`${tabs(this.level)}${str} => ${curFunc}`);
  }

  // ........................................................................
  incLevel(doLog) {
    this.level += 1;
    if (doLog) {
      this.logLevel += 1;
    }
  }

  // ........................................................................
  decLevel(doLog) {
    this.level -= 1;
    if (doLog) {
      this.logLevel -= 1;
    }
  }

  // ........................................................................
  stackAssert(cond, msg) {
    if (!cond) {
      if (doThrowOnError) {
        croak(`${msg}\n${this.dump()}`);
      } else {
        warn(`${msg}\n${this.dump()}`);
      }
    }
  }

  // ........................................................................
  isLogging() {
    var rec;
    rec = this.currentFuncRec();
    if (defined(rec)) {
      return rec.doLog;
    } else {
      return false;
    }
  }

  // ........................................................................
  currentFunc() {
    var rec;
    rec = this.currentFuncRec();
    if (defined(rec)) {
      return rec.funcName;
    } else {
      return undef;
    }
  }

  // ........................................................................
  currentFuncRec() {
    return this.lStack.findLast(function(rec) {
      return !rec.isYielded;
    });
  }

  // ........................................................................
  TOS() {
    if (this.lStack.length === 0) {
      return undef;
    } else {
      return this.lStack[this.lStack.length - 1];
    }
  }

  // ........................................................................
  isActive(funcName) {
    var h, i, len, ref;
    ref = this.lStack;
    for (i = 0, len = ref.length; i < len; i++) {
      h = ref[i];
      if (h.funcName === funcName) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  dump() {
    var lLines, pos;
    lLines = ['-- CALL STACK --'];
    if (this.lStack.length === 0) {
      lLines.push("\t<EMPTY>");
    } else {
      pos = this.lStack.length;
      while (pos > 0) {
        pos -= 1;
        lLines.push("\t" + this.callStr(this.lStack[pos]));
      }
    }
    return lLines.join("\n");
  }

  // ........................................................................
  callStr(item) {
    var sym;
    sym = item.doLog ? 'L' : '-';
    if (item.isYielded) {
      return `${sym} ${item.funcName}*`;
    } else {
      return `${sym} ${item.funcName}`;
    }
  }

};
