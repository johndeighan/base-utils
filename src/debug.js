// Generated by CoffeeScript 2.7.0
// debug.coffee
var callStack, customLogEnter, customLogReturn, customLogString, customLogValue, internalDebugging, lFuncList;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  notdefined,
  OL,
  isString,
  isFunction,
  isEmpty,
  nonEmpty,
  words
} from '@jdeighan/exceptions/utils';

import {
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/exceptions/log';

import {
  CallStack
} from '@jdeighan/exceptions/stack';

callStack = new CallStack();

lFuncList = undef; // array of {funcName, objName, plus}

internalDebugging = false; // set true on setDebugging('debug')

customLogEnter = undef;

customLogReturn = undef;

customLogValue = undef;

customLogString = undef;

// ---------------------------------------------------------------------------
export var setCustomDebugLogger = function(type, func) {
  assert(isFunction(func), "Not a function");
  switch (type) {
    case 'enter':
      customLogEnter = func;
      break;
    case 'return':
      customLogReturn = func;
      break;
    case 'value':
      customLogValue = func;
      break;
    case 'string':
      customLogString = func;
      break;
    default:
      throw new error(`Unknown type: ${OL(type)}`);
  }
};

// ---------------------------------------------------------------------------
export var resetDebugging = function() {
  callStack.reset();
  lFuncList = undef;
  internalDebugging = false;
  customLogEnter = undef;
  customLogReturn = undef;
  customLogValue = undef;
  customLogString = undef;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(...lStrings) {
  var funcNameStr, j, len;
  callStack.reset();
  if (isEmpty(lStrings)) {
    resetDebugging();
    return;
  }
  lFuncList = [];
  for (j = 0, len = lStrings.length; j < len; j++) {
    funcNameStr = lStrings[j];
    assert(isString(funcNameStr), `not a string: ${OL(funcNameStr)}`);
    lFuncList = lFuncList.concat(getFuncList(funcNameStr));
    if (internalDebugging) {
      console.log('lFuncList:');
      console.log(toTAML(lFuncList));
    }
  }
};

// ---------------------------------------------------------------------------
export var getFuncList = function(str) {
  var _, ident1, ident2, j, lMatches, len, plus, ref, word;
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (word === 'debug') {
      internalDebugging = true;
    }
    if (lMatches = word.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?(\+)?$/)) {
      [_, ident1, ident2, plus] = lMatches;
      if (ident2) {
        lFuncList.push({
          funcName: ident2,
          objName: ident1,
          plus: plus === '+'
        });
      } else {
        lFuncList.push({
          funcName: ident1,
          objName: undef,
          plus: plus === '+'
        });
      }
    } else {
      throw new Error(`getFuncList: bad word : ${OL(word)}`);
    }
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lObjects) {
  var doLog, funcName, handled, level, objName, type;
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  if (internalDebugging) {
    console.log(`call debug('${label}')`);
  }
  [type, funcName, objName] = getType(label, lObjects);
  if (internalDebugging) {
    console.log(`   - type = ${OL(type)}, func = ${OL(funcName)}, obj = ${OL(objName)}`);
  }
  switch (type) {
    case 'enter':
    case 'return':
      assert(nonEmpty(funcName), "enter without funcName");
      doLog = funcMatch(funcName, objName);
      break;
    case 'value':
    case 'string':
      assert(isEmpty(funcName), "string with funcName");
      doLog = funcMatch(...callStack.curFunc());
      break;
    default:
      doLog = false; // debugging is turned off, i.e. lFuncList == undef
  }
  if (internalDebugging) {
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  level = callStack.getLevel();
  handled = false;
  switch (type) {
    case 'enter':
      if (doLog) {
        if (defined(customLogEnter)) {
          handled = customLogEnter(label, lObjects, level, funcName, objName);
        }
        if (!handled) {
          logEnter(label, lObjects, level);
        }
      }
      callStack.enter(funcName, objName, lObjects, doLog);
      break;
    case 'return':
      if (doLog) {
        if (defined(customLogReturn)) {
          handled = customLogReturn(label, lObjects, level, funcName, objName);
        }
        if (!handled) {
          logReturn(label, lObjects, level);
        }
      }
      callStack.returnFrom(funcName, objName);
      break;
    case 'value':
      if (doLog) {
        if (defined(customLogValue)) {
          handled = customLogValue(label, lObjects[0], level);
        }
        if (!handled) {
          logValue(label, lObjects[0], level);
        }
      }
      break;
    case 'string':
      if (doLog) {
        if (defined(customLogString)) {
          handled = customLogString(label, level);
        }
        if (!handled) {
          logString(label, level);
        }
      }
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var logEnter = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'plain');
  idPre = getPrefix(level + 1, 'plain');
  itemPre = getPrefix(level + 2, 'dotLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`arg[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logReturn = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'withArrow');
  idPre = getPrefix(level, 'noLastVbar');
  itemPre = getPrefix(level, 'noLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`ret[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logValue = function(label, obj, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOGVALUE(label, obj, labelPre);
};

// ---------------------------------------------------------------------------
export var logString = function(label, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOG(label, labelPre);
};

// ---------------------------------------------------------------------------
export var getType = function(label, lObjects = []) {
  var _, funcName, ident1, ident2, lMatches, objName, type;
  // --- If lFuncList is undef, all debugging is turned off
  if (notdefined(lFuncList)) {
    return [undef, undef, undef];
  }
  if (lMatches = label.match(/^\s*(enter|(?:return.+from))\s+([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?/)) {
    [_, type, ident1, ident2] = lMatches;
    if (ident2) {
      objName = ident1;
      funcName = ident2;
    } else {
      objName = undef;
      funcName = ident1;
    }
    if (type === 'enter') {
      return ['enter', funcName, objName];
    } else {
      return ['return', funcName, objName];
    }
  } else if (lObjects.length === 1) {
    return ['value', undef, undef];
  } else if (lObjects.length === 0) {
    return ['string', undef, undef];
  } else {
    throw new Error("More than 1 object not allowed");
  }
};

// ---------------------------------------------------------------------------
export var funcMatch = function(funcName, objName) {
  var h, j, len;
  if (internalDebugging) {
    console.log(`funcMatch(${OL(funcName)}, ${OL(objName)})`);
  }
  for (j = 0, len = lFuncList.length; j < len; j++) {
    h = lFuncList[j];
    if (defined(h.objName)) {
      if ((funcName === h.funcName) && (objName === h.objName)) {
        return true;
      }
    } else {
      if (h.funcName === funcName) {
        return true;
      }
    }
    if (h.plus && callStack.isActive(h.funcName, h.objName)) {
      return true;
    }
  }
  return false;
};

// ---------------------------------------------------------------------------
