// Generated by CoffeeScript 2.7.0
// debug.coffee
var internalDebugging, lFuncList, lUTLog, logEnter, logResume, logReturn, logString, logType, logValue, logYield;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  notdefined,
  OL,
  isString,
  isFunction,
  isHash,
  isEmpty,
  nonEmpty,
  words,
  firstWord,
  inList,
  oneof,
  arrayToBlock
} from '@jdeighan/exceptions/utils';

import {
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

import {
  LOG,
  LOGVALUE,
  setLogger
} from '@jdeighan/exceptions/log';

import {
  CallStack,
  debugStack
} from '@jdeighan/exceptions/stack';

export var callStack = new CallStack();

lFuncList = []; // array of {funcName, plus}

internalDebugging = false; // set true on setDebugging('debug')

logEnter = undef;

logReturn = undef;

logYield = undef;

logResume = undef;

logValue = undef;

logString = undef;

// ---------------------------------------------------------------------------
export var debugDebug = (debugFlag = false) => {
  internalDebugging = debugFlag;
};

// ---------------------------------------------------------------------------
export var resetDebugging = function() {
  callStack.reset();
  lFuncList = [];
  internalDebugging = false;
  logEnter = stdLogEnter;
  logReturn = stdLogReturn;
  logYield = stdLogYield;
  logResume = stdLogResume;
  logValue = stdLogValue;
  logString = stdLogString;
};

// ---------------------------------------------------------------------------
export var dumpDebugLoggers = function(label = undef) {
  var lLines;
  lLines = [];
  if (nonEmpty(label)) {
    lLines.push(`LOGGERS (${label})`);
  } else {
    lLines.push("LOGGERS");
  }
  lLines.push(`   enter  - ${logType(logEnter, stdLogEnter)}`);
  lLines.push(`   return - ${logType(logReturn, stdLogReturn)}`);
  lLines.push(`   yield  - ${logType(logYield, stdLogYield)}`);
  lLines.push(`   resume - ${logType(logResume, stdLogResume)}`);
  lLines.push(`   value  - ${logType(logValue, stdLogValue)}`);
  lLines.push(`   string - ${logType(logString, stdLogString)}`);
  return console.log(arrayToBlock(lLines));
};

// ---------------------------------------------------------------------------
logType = function(cur, std) {
  if (cur === std) {
    return 'std';
  } else if (defined(cur)) {
    return 'custom';
  } else {
    return 'undef';
  }
};

// ---------------------------------------------------------------------------
export var setDebugging = function(...lParms) {
  var customSet, j, key, len, parm, value;
  // --- pass a hash to set custom loggers
  lFuncList = []; // a package global
  customSet = false;
  for (j = 0, len = lParms.length; j < len; j++) {
    parm = lParms[j];
    if (isString(parm)) {
      lFuncList = lFuncList.concat(getFuncList(parm));
    } else if (isHash(parm)) {
      customSet = true;
      for (key in parm) {
        value = parm[key];
        setCustomDebugLogger(key, value);
      }
    } else {
      croak("Invalid parm to setDebugging()");
    }
  }
  if (internalDebugging) {
    console.log('lFuncList:');
    console.log(toTAML(lFuncList));
    if (customSet) {
      dumpDebugLoggers();
    }
  }
};

// ---------------------------------------------------------------------------
export var setCustomDebugLogger = function(type, func) {
  assert(isFunction(func), "Not a function");
  switch (type) {
    case 'enter':
      logEnter = func;
      break;
    case 'returnFrom':
      logReturn = func;
      break;
    case 'yield':
      logYield = func;
      break;
    case 'resume':
      logResume = func;
      break;
    case 'value':
      logValue = func;
      break;
    case 'string':
      logString = func;
      break;
    default:
      throw new Error(`Unknown type: ${OL(type)}`);
  }
};

// ---------------------------------------------------------------------------
export var getFuncList = function(str) {
  var fullName, j, len, modifier, ref, word;
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (word === 'debug') {
      internalDebugging = true;
    }
    [fullName, modifier] = parseFunc(word);
    assert(defined(fullName), `Bad debug object: ${OL(word)}`);
    lFuncList.push({
      fullName,
      plus: modifier === '+'
    });
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
// simple redirect to an array - useful in unit tests
lUTLog = undef;

export var dbgReset = () => {
  lUTLog = [];
};

export var dbgGetLog = () => {
  var result;
  result = arrayToBlock(lUTLog);
  lUTLog = undef;
  return result;
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lValues) {
  var funcName, type;
  if (internalDebugging) {
    console.log(`call debug('${label}')`);
  }
  [type, funcName] = getType(label, lValues);
  switch (type) {
    case 'enter':
      dbgEnter(funcName, ...lValues);
      break;
    case 'returnFrom':
      dbgReturn(funcName, ...lValues);
      break;
    case 'yield':
      dbgYield(funcName, ...lValues);
      break;
    case 'resume':
      dbgResume(funcName);
      break;
    case 'value':
      dbgValue(label, lValues[0]);
      break;
    case 'string':
      dbgString(label);
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var dbgEnter = function(funcName, ...lValues) {
  var doLog, level, nVals, orgLogger, result;
  assert(isString(funcName), "not a string");
  doLog = funcMatch(funcName);
  if (internalDebugging) {
    nVals = lValues.length;
    console.log(`dbgEnter(${OL(funcName)},${OL(nVals)} vals)`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logEnter(funcName, lValues, level);
    if (result === false) {
      stdLogEnter(funcName, lValues, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  callStack.enter(funcName, lValues, doLog);
  return true;
};

// ---------------------------------------------------------------------------
export var dbgReturn = function(funcName, ...lValues) {
  var doLog, level, nVals, orgLogger, result;
  assert(isString(funcName), "not a string");
  doLog = callStack.isLogging();
  if (internalDebugging) {
    nVals = lValues.length;
    console.log(`dbgReturn(${OL(funcName)},${OL(nVals)} vals)`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logReturn(funcName, lValues, level);
    if (result === false) {
      stdLogReturn(funcName, lValues, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  callStack.returnFrom(funcName, lValues);
  return true;
};

// ---------------------------------------------------------------------------
export var dbgYield = function(funcName, ...lValues) {
  var doLog, level, nVals, orgLogger, result;
  assert(isString(funcName), "not a string");
  doLog = callStack.isLogging();
  if (internalDebugging) {
    nVals = lValues.length;
    console.log(`dbgYield(${OL(funcName)},${OL(nVals)} vals)`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logYield(funcName, lValues, level);
    if (result === false) {
      stdLogYield(funcName, lValues, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  callStack.yield(funcName, lValues);
  return true;
};

// ---------------------------------------------------------------------------
export var dbgResume = function(funcName) {
  var doLog, level, orgLogger, result;
  assert(isString(funcName), "not a string");
  doLog = callStack.isLogging();
  if (internalDebugging) {
    console.log(`dbgResume(${OL(funcName)})`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logResume(funcName, level);
    if (result === false) {
      stdLogResume(funcName, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  callStack.resume(funcName);
  return true;
};

// ---------------------------------------------------------------------------
export var dbgValue = function(str, value) {
  var doLog, level, orgLogger, result;
  assert(isString(str), "not a string");
  doLog = callStack.isLogging();
  if (internalDebugging) {
    console.log(`dbgValue(${OL(str)},${OL(value)})`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logValue(str, value, level);
    if (result === false) {
      stdLogValue(str, value, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var dbgString = function(str) {
  var doLog, level, orgLogger, result;
  assert(isString(str), "not a string");
  doLog = callStack.isLogging();
  if (internalDebugging) {
    console.log(`dbgString(${OL(str)})`);
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  if (doLog) {
    if (defined(lUTLog)) {
      orgLogger = setLogger((str) => {
        return lUTLog.push(str);
      });
    }
    level = callStack.getIndentLevel();
    result = logString(str, level);
    if (result === false) {
      stdLogString(str, level);
    }
    if (defined(lUTLog)) {
      setLogger(orgLogger);
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var dbg = function(...lArgs) {
  if (lArgs.length === 1) {
    return dbgString(lArgs[0]);
  } else {
    return dbgValue(lArgs[0], lArgs[1]);
  }
};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//    Only these 6 functions ever call LOG or LOGVALUE
export var stdLogEnter = function(funcName, lValues, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'plain');
  idPre = getPrefix(level + 1, 'plain');
  itemPre = getPrefix(level + 2, 'dotLast2Vbars');
  LOG(`enter ${funcName}`, labelPre);
  for (i = j = 0, len = lValues.length; j < len; i = ++j) {
    obj = lValues[i];
    LOGVALUE(`arg[${i}]`, obj, idPre, itemPre);
  }
  return true;
};

// ---------------------------------------------------------------------------
export var stdLogReturn = function(funcName, lValues, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'withArrow');
  idPre = getPrefix(level, 'noLastVbar');
  itemPre = getPrefix(level, 'noLast2Vbars');
  LOG(`return from ${funcName}`, labelPre);
  for (i = j = 0, len = lValues.length; j < len; i = ++j) {
    obj = lValues[i];
    LOGVALUE(`ret[${i}]`, obj, idPre, itemPre);
  }
  return true;
};

// ---------------------------------------------------------------------------
export var stdLogYield = function(funcName, lValues, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'plain');
  idPre = getPrefix(level + 1, 'plain');
  itemPre = getPrefix(level + 2, 'dotLast2Vbars');
  LOG(`yield ${funcName}`, labelPre);
  for (i = j = 0, len = lValues.length; j < len; i = ++j) {
    obj = lValues[i];
    LOGVALUE(`arg[${i}]`, obj, idPre, itemPre);
  }
  return true;
};

// ---------------------------------------------------------------------------
export var stdLogResume = function(funcName, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOG(`resume ${funcName}`, labelPre);
  return true;
};

// ---------------------------------------------------------------------------
export var stdLogValue = function(label, obj, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOGVALUE(label, obj, labelPre);
  return true;
};

// ---------------------------------------------------------------------------
export var stdLogString = function(label, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOG(label, labelPre);
  return true;
};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var getType = function(label, lValues = []) {
  var lMatches;
  // --- returns [type, funcName]
  //     <type> is one of:
  //        'enter'  - funcName is set
  //        'returnFrom' - funcName is set
  //        'yield'  - funcName is set
  //        'resume' - funcName is set
  //        'string' - funcName is undef
  //        'value'  - funcName is undef
  if (lMatches = label.match(/^(enter|yield|resume)\s+([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)(?:\(\))?$/)) {
    return [lMatches[1], lMatches[2]];
  }
  if (lMatches = label.match(/^return\s+from\s+([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)(?:\(\))?$/)) {
    return ['returnFrom', lMatches[1]];
  }
  // --- Check for deprecated forms
  assert(!oneof(firstWord(label), 'enter', 'returnFrom', 'yield', 'resume'), `deprecated form for debug(): ${OL(label)}`);
  // --- if none of the above returned, then...
  if (lValues.length === 1) {
    return ['value', undef];
  } else if (lValues.length === 0) {
    return ['string', undef];
  } else {
    throw new Error("More than 1 object not allowed here");
  }
};

// ---------------------------------------------------------------------------
export var funcMatch = function(fullName) {
  var h, j, len;
  // --- fullName came from a call to debug()
  if (internalDebugging) {
    console.log(`funcMatch(${OL(fullName)})`);
  }
  if (defined(lFuncList)) {
    for (j = 0, len = lFuncList.length; j < len; j++) {
      h = lFuncList[j];
      if (h.fullName === fullName) {
        return true;
      }
      if (h.plus && callStack.isActive(fullName)) {
        return true;
      }
    }
  }
  return false;
};

// ........................................................................
export var parseFunc = function(str) {
  var _, fullName, lMatches, modifier;
  // --- returns [fullName, modifier]
  if (lMatches = str.match(/^([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)(\+)?$/)) {
    [_, fullName, modifier] = lMatches;
    return [fullName, modifier];
  } else {
    return [undef, undef];
  }
};

// ---------------------------------------------------------------------------
resetDebugging();
