// Generated by CoffeeScript 2.7.0
// debug.coffee
var callStack, customLogContinue, customLogEnter, customLogReturn, customLogString, customLogValue, customLogYield, internalDebugging, lFuncList;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  notdefined,
  OL,
  isString,
  isFunction,
  isEmpty,
  nonEmpty,
  words,
  inList
} from '@jdeighan/exceptions/utils';

import {
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/exceptions/log';

import {
  CallStack
} from '@jdeighan/exceptions/stack';

callStack = new CallStack();

lFuncList = undef; // array of {funcName, plus}

internalDebugging = false; // set true on setDebugging('debug')

customLogEnter = undef;

customLogReturn = undef;

customLogYield = undef;

customLogContinue = undef;

customLogValue = undef;

customLogString = undef;

// ---------------------------------------------------------------------------
export var setCustomDebugLogger = function(type, func) {
  assert(isFunction(func), "Not a function");
  switch (type) {
    case 'enter':
      customLogEnter = func;
      break;
    case 'return':
      customLogReturn = func;
      break;
    case 'value':
      customLogValue = func;
      break;
    case 'string':
      customLogString = func;
      break;
    default:
      throw new error(`Unknown type: ${OL(type)}`);
  }
};

// ---------------------------------------------------------------------------
export var resetDebugging = function() {
  callStack.reset();
  lFuncList = undef;
  internalDebugging = false;
  customLogEnter = undef;
  customLogReturn = undef;
  customLogValue = undef;
  customLogString = undef;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(...lStrings) {
  var j, len, str;
  callStack.reset();
  if (isEmpty(lStrings)) {
    resetDebugging();
    return;
  }
  lFuncList = [];
  for (j = 0, len = lStrings.length; j < len; j++) {
    str = lStrings[j];
    assert(isString(str), `not a string: ${OL(str)}`);
    lFuncList = lFuncList.concat(getFuncList(str));
    if (internalDebugging) {
      console.log('lFuncList:');
      console.log(toTAML(lFuncList));
    }
  }
};

// ---------------------------------------------------------------------------
export var getFuncList = function(str) {
  var fullName, j, len, modifier, ref, word;
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (word === 'debug') {
      internalDebugging = true;
    }
    [fullName, modifier] = parseFunc(word);
    assert(defined(fullName), `Bad debug object: ${OL(word)}`);
    lFuncList.push({
      fullName,
      plus: modifier === '+'
    });
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lObjects) {
  var doLog, funcName, handled, level, type;
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  if (internalDebugging) {
    console.log(`call debug('${label}')`);
  }
  if (notdefined(lFuncList)) {
    type = undef;
  } else {
    [type, funcName] = getType(label, lObjects);
  }
  if (internalDebugging) {
    console.log(`   - type = ${OL(type)}`);
    console.log(`   - func = ${OL(funcName)}`);
  }
  switch (type) {
    case 'enter':
    case 'return':
    case 'yield':
    case 'continue':
      assert(nonEmpty(funcName), "enter without funcName");
      doLog = funcMatch(funcName);
      break;
    case 'value':
    case 'string':
      assert(isEmpty(funcName), "string with funcName");
      doLog = funcMatch(callStack.curFunc());
      break;
    default:
      doLog = false; // debugging is turned off, i.e. lFuncList == undef
  }
  if (internalDebugging) {
    console.log(`   - doLog = ${OL(doLog)}`);
  }
  level = callStack.getLevel();
  handled = false;
  switch (type) {
    case 'enter':
      if (doLog) {
        if (defined(customLogEnter)) {
          handled = customLogEnter(label, lObjects, level, funcName);
        }
        if (!handled) {
          logEnter(label, lObjects, level);
        }
      }
      callStack.enter(funcName, lObjects, doLog);
      break;
    case 'return':
      if (doLog) {
        if (defined(customLogReturn)) {
          handled = customLogReturn(label, lObjects, level, funcName);
        }
        if (!handled) {
          logReturn(label, lObjects, level);
        }
      }
      callStack.returnFrom(funcName);
      break;
    case 'yield':
      if (doLog) {
        if (defined(customLogYield)) {
          handled = customLogYield(label, lObjects, level, funcName);
        }
        if (!handled) {
          logYield(label, lObjects, level);
        }
      }
      callStack.yield(funcName, lObjects, doLog);
      break;
    case 'continue':
      if (doLog) {
        if (defined(customLogContinue)) {
          handled = customLogContinue(label, lObjects, level, funcName);
        }
        if (!handled) {
          logContinue(label, lObjects, level);
        }
      }
      callStack.continue(funcName, lObjects, doLog);
      break;
    case 'value':
      if (doLog) {
        if (defined(customLogValue)) {
          handled = customLogValue(label, lObjects[0], level);
        }
        if (!handled) {
          logValue(label, lObjects[0], level);
        }
      }
      break;
    case 'string':
      if (doLog) {
        if (defined(customLogString)) {
          handled = customLogString(label, level);
        }
        if (!handled) {
          logString(label, level);
        }
      }
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var logEnter = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'plain');
  idPre = getPrefix(level + 1, 'plain');
  itemPre = getPrefix(level + 2, 'dotLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`arg[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logReturn = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'withArrow');
  idPre = getPrefix(level, 'noLastVbar');
  itemPre = getPrefix(level, 'noLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`ret[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logYield = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'plain');
  idPre = getPrefix(level + 1, 'plain');
  itemPre = getPrefix(level + 2, 'dotLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`arg[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logContinue = function(label, lObjects, level) {
  var i, idPre, itemPre, j, labelPre, len, obj;
  labelPre = getPrefix(level, 'withArrow');
  idPre = getPrefix(level, 'noLastVbar');
  itemPre = getPrefix(level, 'noLast2Vbars');
  LOG(label, labelPre);
  for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
    obj = lObjects[i];
    LOGVALUE(`ret[${i}]`, obj, idPre, itemPre);
  }
};

// ---------------------------------------------------------------------------
export var logValue = function(label, obj, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOGVALUE(label, obj, labelPre);
};

// ---------------------------------------------------------------------------
export var logString = function(label, level) {
  var labelPre;
  labelPre = getPrefix(level, 'plain');
  LOG(label, labelPre);
};

// ---------------------------------------------------------------------------
export var getType = function(label, lObjects = []) {
  var _, funcName, lMatches, typeStr;
  // --- returns [type, funcName], where funcName might be undef
  if (lMatches = label.match(/^(enter|(?:return\b.+from)|(?:yield\b.+from)|continue)\s+([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)/)) {
    [_, typeStr, funcName] = lMatches;
    return [words(typeStr)[0], funcName];
  } else if (lObjects.length === 1) {
    return ['value', undef];
  } else if (lObjects.length === 0) {
    return ['string', undef];
  } else {
    throw new Error("More than 1 object not allowed");
  }
};

// ---------------------------------------------------------------------------
export var funcMatch = function(fullName) {
  var h, j, len;
  // --- fullName came from a call to debug()
  if (internalDebugging) {
    console.log(`funcMatch(${OL(fullName)})`);
  }
  for (j = 0, len = lFuncList.length; j < len; j++) {
    h = lFuncList[j];
    if (h.fullName === fullName) {
      return true;
    }
    if (h.plus && callStack.isActive(fullName)) {
      return true;
    }
  }
  return false;
};

// ........................................................................
export var parseFunc = function(str) {
  var _, fullName, lMatches, modifier;
  // --- returns [fullName, modifier]
  if (lMatches = str.match(/^([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)(\+)?$/)) {
    [_, fullName, modifier] = lMatches;
    return [fullName, modifier];
  } else {
    return [undef, undef];
  }
};

// ---------------------------------------------------------------------------
