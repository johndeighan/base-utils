// Generated by CoffeeScript 2.7.0
// debug.coffee
var callStack, internalDebugging, lFuncList;

import {
  strict as assert
} from 'node:assert';

import {
  undef,
  defined,
  notdefined,
  OL,
  isString,
  isEmpty,
  nonEmpty,
  words
} from '@jdeighan/exceptions/utils';

import {
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  getPrefix
} from '@jdeighan/exceptions/prefix';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/exceptions/log';

import {
  CallStack
} from '@jdeighan/exceptions/stack';

callStack = new CallStack();

lFuncList = undef; // array of {funcName, objName, plus}

internalDebugging = false; // set true on setDebugging('debug')


// ---------------------------------------------------------------------------
export var resetDebugging = function() {
  callStack.reset();
  lFuncList = undef;
  internalDebugging = false;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(funcNameStr) {
  callStack.reset();
  if (isEmpty(funcNameStr)) {
    resetDebugging();
  } else {
    assert(isString(funcNameStr), `not a string: ${OL(funcNameStr)}`);
    lFuncList = getFuncList(funcNameStr);
    if (internalDebugging) {
      console.log('lFuncList:');
      console.log(toTAML(lFuncList));
    }
  }
};

// ---------------------------------------------------------------------------
export var getFuncList = function(str) {
  var _, ident1, ident2, j, lMatches, len, plus, ref, word;
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (word === 'debug') {
      internalDebugging = true;
    }
    if (lMatches = word.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?(\+)?$/)) {
      [_, ident1, ident2, plus] = lMatches;
      if (ident2) {
        lFuncList.push({
          funcName: ident2,
          objName: ident1,
          plus: plus === '+'
        });
      } else {
        lFuncList.push({
          funcName: ident1,
          objName: undef,
          plus: plus === '+'
        });
      }
    } else {
      throw new Error(`getFuncList: bad word : ${OL(word)}`);
    }
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
export var debug = function(orgLabel, ...lObjects) {
  var funcName, label, objName, type;
  assert(isString(orgLabel), `1st arg ${OL(orgLabel)} should be a string`);
  if (internalDebugging) {
    console.log(`call debug('${orgLabel}')`);
  }
  [type, funcName, objName] = getType(orgLabel);
  if (internalDebugging) {
    console.log(`   - type = ${OL(type)}, func = ${OL(funcName)}, obj = ${OL(objName)}`);
  }
  switch (type) {
    case 'enter':
      assert(nonEmpty(funcName), "enter without funcName");
      label = shouldLogEnter(orgLabel, funcName, objName);
      break;
    case 'return':
      assert(nonEmpty(funcName), "return without funcName");
      label = shouldLogReturn(orgLabel, funcName, objName);
      break;
    case 'string':
      assert(isEmpty(funcName), "string with funcName");
      label = shouldLogString(orgLabel);
      break;
    default:
      label = undef; // debugging is turned off, i.e. lFuncList == undef
  }
  if (internalDebugging) {
    console.log(`   - label = ${OL(label)}`);
  }
  if (defined(label)) {
    label = interp(label);
  }
  switch (type) {
    case 'enter':
      if (defined(label)) {
        doTheLogging(type, label, lObjects);
      }
      callStack.enter(funcName, objName, lObjects, defined(label));
      break;
    case 'return':
      if (defined(label)) {
        doTheLogging(type, label, lObjects);
      }
      callStack.returnFrom(funcName, objName);
      break;
    case 'string':
      if (defined(label)) {
        doTheLogging(type, label, lObjects);
      }
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var getType = function(label) {
  var _, funcName, ident1, ident2, lMatches, objName, type;
  // --- If lFuncList is undef, all debugging is turned off
  if (notdefined(lFuncList)) {
    return [undef, undef, undef];
  }
  if (lMatches = label.match(/^\s*(enter|(?:return.+from))\s+([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?/)) {
    [_, type, ident1, ident2] = lMatches;
    if (ident2) {
      objName = ident1;
      funcName = ident2;
    } else {
      objName = undef;
      funcName = ident1;
    }
    if (type === 'enter') {
      return ['enter', funcName, objName];
    } else {
      return ['return', funcName, objName];
    }
  } else {
    return ['string', undef, undef];
  }
};

// ---------------------------------------------------------------------------
export var shouldLogEnter = function(label, funcName, objName) {
  var result;
  // --- funcName won't be on the stack yet
  //     returns the (possibly modified) label to log
  if (funcMatch(funcName, objName)) {
    return label;
  }
  // --- As a special case, if we enter a function where we will not
  //     be logging, but we were logging in the calling function,
  //     we'll log out the call itself
  if (funcMatch(...callStack.curFunc())) {
    result = label.replace('enter', 'call');
    return result;
  }
  return undef;
};

// ---------------------------------------------------------------------------
export var shouldLogReturn = function(label, funcName, objName) {
  //     returns the (possibly modified) label to log
  if (funcMatch(funcName, objName)) {
    return label;
  } else {
    return undef;
  }
};

// ---------------------------------------------------------------------------
export var shouldLogString = function(label) {
  //     returns the (possibly modified) label to log
  if (funcMatch(...callStack.curFunc())) {
    return label;
  } else {
    return undef;
  }
};

// ---------------------------------------------------------------------------
export var funcMatch = function(funcName, objName) {
  var h, j, len;
  if (internalDebugging) {
    console.log(`funcMatch(${OL(funcName)}, ${OL(objName)})`);
  }
  for (j = 0, len = lFuncList.length; j < len; j++) {
    h = lFuncList[j];
    if (defined(h.objName)) {
      if ((funcName === h.funcName) && (objName === h.objName)) {
        return true;
      }
    } else {
      if (h.funcName === funcName) {
        return true;
      }
    }
    if (h.plus && callStack.isActive(h.funcName, h.objName)) {
      return true;
    }
  }
  return false;
};

// ---------------------------------------------------------------------------
export var doTheLogging = function(type, label, lObjects) {
  var i, itemPre, j, k, len, len1, level, nVals, obj, pre;
  assert(isString(label), `non-string label ${OL(label)}`);
  level = callStack.getLevel();
  switch (type) {
    case 'enter':
      LOG(label, getPrefix(level, 'plain'));
      pre = getPrefix(level + 1, 'plain');
      itemPre = getPrefix(level + 2, 'dotLast2Vbars');
      for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
        obj = lObjects[i];
        LOGVALUE(`arg[${i}]`, obj, pre, itemPre);
      }
      break;
    case 'return':
      LOG(label, getPrefix(level, 'withArrow'));
      pre = getPrefix(level, 'noLastVbar');
      itemPre = getPrefix(level, 'noLast2Vbars');
      for (i = k = 0, len1 = lObjects.length; k < len1; i = ++k) {
        obj = lObjects[i];
        LOGVALUE(`ret[${i}]`, obj, pre, itemPre);
      }
      break;
    case 'string':
      pre = getPrefix(level, 'plain');
      itemPre = getPrefix(level + 1, 'noLastVbar');
      nVals = lObjects.length;
      if (nVals === 0) {
        LOG(label, pre);
      } else {
        assert(nVals === 1, `Only 1 value allowed, ${nVals} found`);
        LOGVALUE(label, lObjects[0], pre);
      }
  }
};

// ---------------------------------------------------------------------------
export var interp = function(label) {
  return label.replace(/\$(\@)?([A-Za-z_][A-Za-z0-9_]*)/g, function(_, atSign, varName) {
    if (atSign) {
      return `\#{OL(@${varName})\}`;
    } else {
      return `\#{OL(${varName})\}`;
    }
  });
};

// ---------------------------------------------------------------------------
