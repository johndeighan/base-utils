// Generated by CoffeeScript 2.7.0
// utils.coffee
var myReplacer;

import yaml from 'js-yaml';

import {
  assert,
  croak
} from '@jdeighan/exceptions';

export const undef = undefined;

export var sep_dash = '-'.repeat(42);

export var sep_eq = '='.repeat(42);

// ---------------------------------------------------------------------------
//   pass - do nothing
export var pass = function() {};

// ---------------------------------------------------------------------------
export var defined = (obj) => {
  return (obj !== undef) && (obj !== null);
};

// ---------------------------------------------------------------------------
export var notdefined = (obj) => {
  return (obj === undef) || (obj === null);
};

// ---------------------------------------------------------------------------
export var untabify = (str) => {
  return str.replace(/\t/g, ' '.repeat(3));
};

// ---------------------------------------------------------------------------
// --- a replacer is (key, value) -> newvalue
myReplacer = function(name, value) {
  if (isString(value)) {
    return escapeStr(value);
  } else if (isObject(value, ['tamlReplacer'])) {
    return value.tamlReplacer();
  } else {
    return value;
  }
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var toTAML = function(obj, hOptions = {}) {
  var escape, replacer, sortKeys, str, useTabs;
  ({useTabs, sortKeys, escape, replacer} = hOptions);
  if (notdefined(replacer)) {
    replacer = myReplacer;
  }
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 3,
    sortKeys: !!sortKeys,
    lineWidth: -1,
    replacer
  });
  if (useTabs) {
    str = str.replace(/   /g, "\t");
  }
  return "---\n" + chomp(str);
};

// ---------------------------------------------------------------------------
//   escapeStr - escape newlines, TAB chars, etc.
export var hDefEsc = {
  "\n": '®',
  "\t": '→',
  " ": '˳'
};

export var escapeStr = function(str, hEscape = hDefEsc) {
  var ch, lParts;
  assert(isString(str), "escapeStr(): not a string");
  lParts = (function() {
    var i, len1, ref, results;
    ref = str.split('');
    results = [];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      ch = ref[i];
      if (hEscape[ch] != null) {
        results.push(hEscape[ch]);
      } else {
        results.push(ch);
      }
    }
    return results;
  })();
  return lParts.join('');
};

// ---------------------------------------------------------------------------
export var OL = function(obj) {
  if (defined(obj)) {
    if (isString(obj)) {
      return `'${escapeStr(obj)}'`;
    } else {
      return JSON.stringify(obj);
    }
  } else {
    return 'undef';
  }
};

// ---------------------------------------------------------------------------
export var jsType = function(x) {
  var lKeys;
  if (notdefined(x)) {
    return [undef, undef];
  } else if (isString(x)) {
    if (x.match(/^\s*$/)) {
      return ['string', 'empty'];
    } else {
      return ['string', undef];
    }
  } else if (isNumber(x)) {
    if (Number.isInteger(x)) {
      return ['number', 'integer'];
    } else {
      return ['number', undef];
    }
  } else if (isBoolean(x)) {
    return ['boolean', undef];
  } else if (isHash(x)) {
    lKeys = Object.keys(x);
    if (lKeys.length === 0) {
      return ['hash', 'empty'];
    } else {
      return ['hash', undef];
    }
  } else if (isArray(x)) {
    if (x.length === 0) {
      return ['array', 'empty'];
    } else {
      return ['array', undef];
    }
  } else if (isRegExp(x)) {
    return ['regexp', undef];
  } else if (isConstructor(x)) {
    return ['function', 'constructor'];
  } else if (isFunction(x)) {
    return ['function', undef];
  } else if (isObject(x)) {
    return ['object', undef];
  } else {
    throw new Error(`Unknown type: ${OL(x)}`);
  }
};

// ---------------------------------------------------------------------------
export var isString = (x) => {
  return (typeof x === 'string') || (x instanceof String);
};

// ---------------------------------------------------------------------------
export var isNumber = function(x, hOptions = undef) {
  var max, min, result;
  result = (typeof x === 'number') || (x instanceof Number);
  if (result && defined(hOptions)) {
    if (!isHash(hOptions)) {
      LOG(`2nd arg not a hash: ${OL(hOptions)}`);
      process.exit();
    }
    ({min, max} = hOptions);
    if (defined(min) && (x < min)) {
      result = false;
    }
    if (defined(max) && (x > max)) {
      result = false;
    }
  }
  return result;
};

// ---------------------------------------------------------------------------
export var isInteger = function(x, hOptions = {}) {
  var result;
  if (typeof x === 'number') {
    result = Number.isInteger(x);
  } else if (x instanceof Number) {
    result = Number.isInteger(x.valueOf());
  } else {
    result = false;
  }
  if (result) {
    if (defined(hOptions.min) && (x < hOptions.min)) {
      result = false;
    }
    if (defined(hOptions.max) && (x > hOptions.max)) {
      result = false;
    }
  }
  return result;
};

// ---------------------------------------------------------------------------
export var getClassName = function(obj) {
  if (typeof obj !== 'object') {
    return undef;
  }
  return obj.constructor.name;
};

// ---------------------------------------------------------------------------
export var isHash = function(x, lKeys) {
  var i, key, len1;
  if (!x || (getClassName(x) !== 'Object')) {
    return false;
  }
  if (defined(lKeys)) {
    if (!isArray(lKeys)) {
      LOG("isHash(): lKeys not an array");
      process.exit();
    }
    for (i = 0, len1 = lKeys.length; i < len1; i++) {
      key = lKeys[i];
      if (!x.hasOwnProperty(key)) {
        return false;
      }
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var isArray = function(x) {
  return Array.isArray(x);
};

// ---------------------------------------------------------------------------
export var isBoolean = function(x) {
  return typeof x === 'boolean';
};

// ---------------------------------------------------------------------------
export var isConstructor = function(f) {
  var err;
  try {
    new f();
  } catch (error) {
    err = error;
    if (err.message.indexOf('is not a constructor') >= 0) {
      return false;
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var isFunction = function(x) {
  return typeof x === 'function';
};

// ---------------------------------------------------------------------------
export var isRegExp = function(x) {
  return x instanceof RegExp;
};

// ---------------------------------------------------------------------------
export var isObject = function(x, lReqKeys = undef) {
  var i, key, len1, result;
  result = (typeof x === 'object') && !isString(x) && !isArray(x) && !isHash(x) && !isNumber(x);
  if (result) {
    if (defined(lReqKeys)) {
      if (!isArray(lReqKeys)) {
        LOG("lReqKeys is not an array");
        process.exit();
      }
      for (i = 0, len1 = lReqKeys.length; i < len1; i++) {
        key = lReqKeys[i];
        if (!x.hasOwnProperty(key)) {
          return false;
        }
      }
    }
    return true;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
// This is useful for debugging
export var LOG = function(...lArgs) {
  var item, label;
  switch (lArgs.length) {
    case 0:
      console.log("");
      break;
    case 1:
      console.log(lArgs[0]);
      break;
    case 2:
      // --- There's both a label and an item
      [label, item] = lArgs;
      if (item === undef) {
        console.log(`${label} = undef`);
      } else if (item === null) {
        console.log(`${label} = null`);
      } else {
        console.log(sep_dash);
        console.log(`${label}:`);
        if (isString(item)) {
          console.log(untabify(item));
        } else {
          console.log(toTAML(item));
        }
        console.log(sep_dash);
      }
      break;
    default:
      console.log(`TOO MANY ARGS for LOG(): ${lArgs.length}`);
  }
  return true; // to allow use in boolean expressions
};


// --- Use this instead to make it easier to remove all instances
export var DEBUG = LOG; // synonym


// ---------------------------------------------------------------------------
//   isEmpty
//      - string is whitespace, array has no elements, hash has no keys
export var isEmpty = function(x) {
  if ((x === undef) || (x === null)) {
    return true;
  }
  if (isString(x)) {
    return x.match(/^\s*$/);
  }
  if (isArray(x)) {
    return x.length === 0;
  }
  if (isHash(x)) {
    return Object.keys(x).length === 0;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
//   nonEmpty
//      - string has non-whitespace, array has elements, hash has keys
export var nonEmpty = function(x) {
  if (x == null) {
    return false;
  }
  if (isString(x)) {
    return !x.match(/^\s*$/);
  }
  if (isArray(x)) {
    return x.length > 0;
  }
  if (isHash(x)) {
    return Object.keys(x).length > 0;
  } else {
    return croak("isEmpty(): Invalid parameter");
  }
};

// ---------------------------------------------------------------------------
//   blockToArray - split a block into lines
export var blockToArray = function(block) {
  var lLines, len;
  if ((block === undef) || (block === '')) {
    return [];
  } else {
    lLines = block.split(/\r?\n/);
    // --- remove trailing empty lines
    len = lLines.length;
    while ((len > 0) && isEmpty(lLines[len - 1])) {
      lLines.pop();
      len -= 1;
    }
    return lLines;
  }
};

// ---------------------------------------------------------------------------
//   arrayToBlock - block and lines in block will have no trailing whitespace
export var arrayToBlock = function(lLines) {
  if (lLines === undef) {
    return undef;
  }
  assert(isArray(lLines), "lLines is not an array");
  lLines = lLines.filter((line) => {
    return defined(line);
  });
  if (lLines.length === 0) {
    return undef;
  } else {
    return rtrim(lLines.join('\n'));
  }
};

// ---------------------------------------------------------------------------
export var chomp = function(str) {
  var len, tail;
  len = str.length;
  if (len === 0) {
    return '';
  } else if (len === 1) {
    if ((str === "\r") || (str === "\n")) {
      return '';
    } else {
      return str;
    }
  } else {
    // --- check the last 2 characters
    tail = str.substring(len - 2);
    if (tail === "\r\n") {
      return str.substring(0, len - 2);
    } else {
      tail = str.substring(len - 1);
      if (tail === "\n") {
        return str.substring(0, len - 1);
      } else {
        return str;
      }
    }
  }
};

// ---------------------------------------------------------------------------
//   rtrim - strip trailing whitespace
export var rtrim = function(line) {
  var lMatches, n;
  assert(isString(line), "rtrim(): line is not a string");
  lMatches = line.match(/\s+$/);
  if (lMatches != null) {
    n = lMatches[0].length; // num chars to remove
    return line.substring(0, line.length - n);
  } else {
    return line;
  }
};

// ---------------------------------------------------------------------------
export var setCharsAt = function(str, pos, str2) {
  assert(pos >= 0, `negative pos ${pos} not allowed`);
  assert(pos < str.length, `pos ${pos} not in ${OL(str)}`);
  if (pos + str2.length >= str.length) {
    return str.substring(0, pos) + str2;
  } else {
    return str.substring(0, pos) + str2 + str.substring(pos + str2.length);
  }
};

// ---------------------------------------------------------------------------
export var words = function(str) {
  str = str.trim();
  if (str === '') {
    return [];
  }
  return str.split(/\s+/);
};
