// Generated by CoffeeScript 2.7.0
  // utils.coffee
var myReplacer,
  hasProp = {}.hasOwnProperty;

import assert from 'node:assert/strict';

export const undef = void 0;

// ---------------------------------------------------------------------------
//   pass - do nothing
export var pass = () => {
  return true;
};

// ---------------------------------------------------------------------------
export var defined = (obj) => {
  return (obj !== undef) && (obj !== null);
};

// ---------------------------------------------------------------------------
export var notdefined = (obj) => {
  return (obj === undef) || (obj === null);
};

// ---------------------------------------------------------------------------
export var spaces = (n) => {
  return " ".repeat(n);
};

// ---------------------------------------------------------------------------
export var tabs = (n) => {
  return "\t".repeat(n);
};

// ---------------------------------------------------------------------------
export var untabify = (str, numSpaces = 3) => {
  return str.replace(/\t/g, ' '.repeat(numSpaces));
};

// ---------------------------------------------------------------------------
export var oneof = function(word, ...lWords) {
  return lWords.indexOf(word) >= 0;
};

// ---------------------------------------------------------------------------
export var prefixBlock = (block, prefix) => {
  var lLines, line;
  lLines = (function() {
    var i, len1, ref, results;
    ref = blockToArray(block);
    results = [];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      line = ref[i];
      results.push(`${prefix}${line}`);
    }
    return results;
  })();
  return arrayToBlock(lLines);
};

// ---------------------------------------------------------------------------
//   deepCopy - deep copy an array or object
export var deepCopy = function(obj) {
  var err, newObj, objStr;
  if (obj === undef) {
    return undef;
  }
  objStr = JSON.stringify(obj);
  try {
    newObj = JSON.parse(objStr);
  } catch (error) {
    err = error;
    throw new Error("ERROR: err.message");
  }
  return newObj;
};

// ---------------------------------------------------------------------------
// --- a replacer is (key, value) -> newvalue
myReplacer = function(name, value) {
  if (value === undef) {
    return undef;
  } else if (value === null) {
    return null;
  } else if (isString(value)) {
    return escapeStr(value);
  } else if (typeof value === 'function') {
    return `[Function: ${value.name}]`;
  } else {
    return value;
  }
};

// ---------------------------------------------------------------------------
export var OL = function(obj) {
  if (defined(obj)) {
    if (isString(obj)) {
      return quoted(obj, 'escape');
    } else {
      return JSON.stringify(obj, myReplacer);
    }
  } else if (obj === null) {
    return 'null';
  } else {
    return 'undef';
  }
};

// ---------------------------------------------------------------------------
export var OLS = function(lObjects, sep = ',') {
  var i, lParts, len1, obj;
  assert(isArray(lObjects), "not an array");
  lParts = [];
  for (i = 0, len1 = lObjects.length; i < len1; i++) {
    obj = lObjects[i];
    lParts.push(OL(obj));
  }
  return lParts.join(sep);
};

// ---------------------------------------------------------------------------
export var quoted = (str, escape = undef) => {
  assert(isString(str), "not a string");
  switch (escape) {
    case 'escape':
      str = escapeStr(str);
      break;
    case 'escapeNoNL':
      str = escapeStr(str, hEscNoNL);
      break;
    default:
      pass;
  }
  if (!hasChar(str, "'")) {
    return "'" + str + "'";
  }
  if (!hasChar(str, '"')) {
    return '"' + str + '"';
  }
  return '<' + str + '>';
};

// ---------------------------------------------------------------------------
//   escapeStr - escape newlines, TAB chars, etc.
export var hEsc = {
  "\n": '®',
  "\t": '→',
  " ": '˳'
};

export var hEscNoNL = {
  "\t": '→',
  " ": '˳'
};

export var escapeStr = function(str, hReplace = hEsc) {
  var ch, lParts;
  // --- hReplace can also be a string:
  //        'esc'     - escape space, newline, tab
  //        'escNoNL' - escape space, tab
  if (isString(hReplace)) {
    switch (hReplace) {
      case 'esc':
        hReplace = hEsc;
        break;
      case 'escNoNL':
        hReplace = hExcNoNL;
        break;
      default:
        throw new Error("Invalid hReplace string value");
    }
  }
  assert(isString(str), "escapeStr(): not a string");
  lParts = (function() {
    var i, len1, ref, results;
    ref = str.split('');
    results = [];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      ch = ref[i];
      if (defined(hReplace[ch])) {
        results.push(hReplace[ch]);
      } else {
        results.push(ch);
      }
    }
    return results;
  })();
  return lParts.join('');
};

// ---------------------------------------------------------------------------
export var hasChar = (str, ch) => {
  return str.indexOf(ch) >= 0;
};

// ---------------------------------------------------------------------------
//   unescapeStr - unescape newlines, TAB chars, etc.
export var hUnesc = {
  '®': "\n",
  '→': "\t",
  '˳': " "
};

export var unescapeStr = function(str, hReplace = hUnesc) {
  return escapeStr(str, hReplace);
};

// ---------------------------------------------------------------------------
export var inList = (item, ...lStrings) => {
  return lStrings.indexOf(item) >= 0;
};

// ---------------------------------------------------------------------------
export var isString = (x) => {
  return (typeof x === 'string') || (x instanceof String);
};

// ---------------------------------------------------------------------------
export var isNonEmptyString = (x) => {
  return isString(x) && !x.match(/^\s*$/);
};

// ---------------------------------------------------------------------------
export var isIdentifier = (x) => {
  return !!(isString(x) && x.match(/^[A-Za-z_][A-Za-z0-9_]*$/));
};

// ---------------------------------------------------------------------------
export var isFunctionName = (x) => {
  var _, first, lMatches, second;
  if (isString(x) && (lMatches = x.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?$/))) { // allow class method names
    [_, first, second] = lMatches;
    if (nonEmpty(second)) {
      return [first, second];
    } else {
      return [first];
    }
  } else {
    return undef;
  }
};

// ---------------------------------------------------------------------------
export var isNumber = function(x, hOptions = undef) {
  var max, min, result;
  result = (typeof x === 'number') || (x instanceof Number);
  if (result && defined(hOptions)) {
    if (!isHash(hOptions)) {
      LOG(`2nd arg not a hash: ${OL(hOptions)}`);
      process.exit();
    }
    ({min, max} = hOptions);
    if (defined(min) && (x < min)) {
      result = false;
    }
    if (defined(max) && (x > max)) {
      result = false;
    }
  }
  return result;
};

// ---------------------------------------------------------------------------
export var isInteger = function(x, hOptions = {}) {
  var result;
  if (typeof x === 'number') {
    result = Number.isInteger(x);
  } else if (x instanceof Number) {
    result = Number.isInteger(x.valueOf());
  } else {
    result = false;
  }
  if (result) {
    if (defined(hOptions.min) && (x < hOptions.min)) {
      result = false;
    }
    if (defined(hOptions.max) && (x > hOptions.max)) {
      result = false;
    }
  }
  return result;
};

// ---------------------------------------------------------------------------
export var getClassName = function(obj) {
  if (typeof obj !== 'object') {
    return undef;
  }
  return obj.constructor.name;
};

// ---------------------------------------------------------------------------
export var isHash = function(x, lKeys) {
  var i, key, len1;
  if (!x || (getClassName(x) !== 'Object')) {
    return false;
  }
  if (defined(lKeys)) {
    if (isString(lKeys)) {
      lKeys = words(lKeys);
    } else if (!isArray(lKeys)) {
      throw new Error(`lKeys not an array: ${OL(lKeys)}`);
    }
    for (i = 0, len1 = lKeys.length; i < len1; i++) {
      key = lKeys[i];
      if (!x.hasOwnProperty(key)) {
        return false;
      }
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var isArray = function(x) {
  return Array.isArray(x);
};

// ---------------------------------------------------------------------------
export var isBoolean = function(x) {
  return typeof x === 'boolean';
};

// ---------------------------------------------------------------------------
export var isConstructor = function(f) {
  return (typeof f === 'function') && !!f.prototype && (f.prototype.constructor === f);
};

// ---------------------------------------------------------------------------
export var isFunction = function(x) {
  return typeof x === 'function';
};

// ---------------------------------------------------------------------------
export var isRegExp = function(x) {
  return x instanceof RegExp;
};

// ---------------------------------------------------------------------------
export var isObject = function(x, lReqKeys = undef) {
  var _, i, key, lMatches, len1, type;
  if ((typeof x !== 'object') || isString(x) || isArray(x) || isHash(x) || isNumber(x)) {
    return false;
  }
  if (defined(lReqKeys)) {
    if (isString(lReqKeys)) {
      lReqKeys = words(lReqKeys);
    }
    assert(isArray(lReqKeys), `lReqKeys not an array: ${OL(lReqKeys)}`);
    for (i = 0, len1 = lReqKeys.length; i < len1; i++) {
      key = lReqKeys[i];
      type = undef;
      if (lMatches = key.match(/^(\&)(.*)$/)) {
        [_, type, key] = lMatches;
      }
      if (notdefined(x[key])) {
        return false;
      }
      if ((type === '&') && (typeof x[key] !== 'function')) {
        return false;
      }
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var isScalar = function(x) {
  return isNumber(x) || isString(x) || isBoolean(x);
};

// ---------------------------------------------------------------------------
export var jsType = function(x) {
  var lKeys;
  if (x === null) {
    return [undef, 'null'];
  } else if (x === undef) {
    return [undef, 'undef'];
  } else if (isString(x)) {
    if (x.match(/^\s*$/)) {
      return ['string', 'empty'];
    } else {
      return ['string', undef];
    }
  } else if (isNumber(x)) {
    if (Number.isInteger(x)) {
      return ['number', 'integer'];
    } else {
      return ['number', undef];
    }
  } else if (isBoolean(x)) {
    if (x) {
      return ['boolean', 'true'];
    } else {
      return ['boolean', 'false'];
    }
  } else if (isHash(x)) {
    lKeys = Object.keys(x);
    if (lKeys.length === 0) {
      return ['hash', 'empty'];
    } else {
      return ['hash', undef];
    }
  } else if (isArray(x)) {
    if (x.length === 0) {
      return ['array', 'empty'];
    } else {
      return ['array', undef];
    }
  } else if (isRegExp(x)) {
    return ['regexp', undef];
  } else if (isConstructor(x)) {
    return ['function', 'constructor'];
  } else if (isFunction(x)) {
    return ['function', undef];
  } else if (isObject(x)) {
    return ['object', undef];
  } else {
    throw new Error(`Unknown type: ${OL(x)}`);
  }
};

// ---------------------------------------------------------------------------
//   isEmpty
//      - string is whitespace, array has no elements, hash has no keys
export var isEmpty = function(x) {
  if ((x === undef) || (x === null)) {
    return true;
  }
  if (isString(x)) {
    return x.match(/^\s*$/);
  }
  if (isArray(x)) {
    return x.length === 0;
  }
  if (isHash(x)) {
    return Object.keys(x).length === 0;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
//   nonEmpty
//      - string has non-whitespace, array has elements, hash has keys
export var nonEmpty = function(x) {
  if (notdefined(x)) {
    return false;
  }
  if (isString(x)) {
    return !x.match(/^\s*$/);
  }
  if (isArray(x)) {
    return x.length > 0;
  }
  if (isHash(x)) {
    return Object.keys(x).length > 0;
  } else {
    return defined(x);
  }
};

// ---------------------------------------------------------------------------
//   blockToArray - split a block into lines
export var blockToArray = function(block) {
  var lLines;
  if ((block === undef) || (block === '')) {
    return [];
  } else {
    assert(isString(block), `block is ${OL(block)}`);
    lLines = block.split(/\r?\n/);
    return lLines;
  }
};

// ---------------------------------------------------------------------------
export var toArray = function(item) {
  var i, j, lLines, len1, len2, line, ref, str;
  if (isArray(item)) {
    // --- We need to split any strings containing a \n
    lLines = [];
    for (i = 0, len1 = item.length; i < len1; i++) {
      line = item[i];
      if (hasChar(line, "\n")) {
        ref = line.split(/\r?\n/);
        for (j = 0, len2 = ref.length; j < len2; j++) {
          str = ref[j];
          lLines.push(str);
        }
      } else {
        lLines.push(line);
      }
    }
    return lLines;
  } else {
    return blockToArray(item);
  }
};

// ---------------------------------------------------------------------------
//   arrayToBlock - block and lines in block will have no trailing whitespace
export var arrayToBlock = function(lLines, hEsc = undef) {
  var i, lResult, len1, line, result;
  if (lLines === undef) {
    return '';
  }
  assert(isArray(lLines), "lLines is not an array");
  lResult = [];
  for (i = 0, len1 = lLines.length; i < len1; i++) {
    line = lLines[i];
    if (defined(line)) {
      lResult.push(rtrim(line));
    }
  }
  if (lResult.length === 0) {
    return '';
  } else {
    result = lResult.join("\n");
    if (defined(hEsc)) {
      result = escapeStr(result, hEsc);
    }
    return result;
  }
};

// ---------------------------------------------------------------------------
export var toBlock = function(item) {
  if (isString(item)) {
    return item;
  } else {
    return arrayToBlock(item);
  }
};

// ---------------------------------------------------------------------------
export var chomp = function(str) {
  var len, tail;
  len = str.length;
  if (len === 0) {
    return '';
  } else if (len === 1) {
    if ((str === "\r") || (str === "\n")) {
      return '';
    } else {
      return str;
    }
  } else {
    // --- check the last 2 characters
    tail = str.substring(len - 2);
    if (tail === "\r\n") {
      return str.substring(0, len - 2);
    } else {
      tail = str.substring(len - 1);
      if (tail === "\n") {
        return str.substring(0, len - 1);
      } else {
        return str;
      }
    }
  }
};

// ---------------------------------------------------------------------------
//   rtrim - strip trailing whitespace
export var rtrim = function(line) {
  var lMatches, n;
  assert(isString(line), "rtrim(): line is not a string");
  lMatches = line.match(/\s+$/);
  if (defined(lMatches)) {
    n = lMatches[0].length; // num chars to remove
    return line.substring(0, line.length - n);
  } else {
    return line;
  }
};

// ---------------------------------------------------------------------------
export var setCharsAt = function(str, pos, str2) {
  assert(pos >= 0, `negative pos ${pos} not allowed`);
  assert(pos < str.length, `pos ${pos} not in ${OL(str)}`);
  if (pos + str2.length >= str.length) {
    return str.substring(0, pos) + str2;
  } else {
    return str.substring(0, pos) + str2 + str.substring(pos + str2.length);
  }
};

// ---------------------------------------------------------------------------
export var words = function(...lStrings) {
  var i, j, lWords, len1, len2, ref, str, word;
  lWords = [];
  for (i = 0, len1 = lStrings.length; i < len1; i++) {
    str = lStrings[i];
    str = str.trim();
    if (str !== '') {
      ref = str.split(/\s+/);
      for (j = 0, len2 = ref.length; j < len2; j++) {
        word = ref[j];
        lWords.push(word);
      }
    }
  }
  return lWords;
};

// ---------------------------------------------------------------------------
export var firstWord = (str) => {
  var pos;
  pos = str.indexOf(' ');
  if (pos === -1) {
    return str;
  } else {
    return str.substring(0, pos);
  }
};

// ---------------------------------------------------------------------------
export var getOptions = function(options = undef, hDefault = {}) {
  var hOptions, key, subtype, type, value;
  [type, subtype] = jsType(options);
  switch (type) {
    case undef:
      hOptions = {};
      break;
    case 'hash':
      hOptions = options;
      break;
    case 'string':
      hOptions = hashFromString(options);
      break;
    default:
      throw new Error(`options not hash or string: ${OL(options)}`);
  }
  for (key in hDefault) {
    if (!hasProp.call(hDefault, key)) continue;
    value = hDefault[key];
    if (!hOptions.hasOwnProperty(key)) {
      hOptions[key] = value;
    }
  }
  return hOptions;
};

// ---------------------------------------------------------------------------
export var hashFromString = function(str) {
  var _, eq, h, i, ident, lMatches, len1, neg, ref, word;
  assert(isString(str), `not a string: ${OL(str)}`);
  h = {};
  ref = words(str);
  for (i = 0, len1 = ref.length; i < len1; i++) {
    word = ref[i];
    if (lMatches = word.match(/^(\!)?([A-Za-z][A-Za-z_0-9]*)(?:(=)(.*))?$/)) { // negate value
      // identifier
      [_, neg, ident, eq, str] = lMatches;
      if (nonEmpty(eq)) {
        assert(isEmpty(neg), "negation with string value");
        // --- TO DO: interpret backslash escapes
        h[ident] = str;
      } else if (neg) {
        h[ident] = false;
      } else {
        h[ident] = true;
      }
    } else {
      throw new Error(`Invalid word ${OL(word)}`);
    }
  }
  return h;
};

// ---------------------------------------------------------------------------
export var warn = (msg) => {
  console.log(`WARNING: ${msg}`);
};
