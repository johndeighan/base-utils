// Generated by CoffeeScript 2.7.0
// bootstrap-utils.coffee
import assertLib from 'node:assert';

import {
  execSync
} from 'node:child_process';

import fs from 'node:fs';

import {
  globSync
} from 'glob';

import NReadLines from 'n-readlines';

import YAML from 'yaml';

import CoffeeScript from 'coffeescript';

const undef = void 0;

// ---------------------------------------------------------------------------
// low-level version of assert()
export var assert = (cond, msg) => {
  assertLib.ok(cond, msg);
  return true;
};

// ---------------------------------------------------------------------------
// These are duplicates of standard functions
// However, when starting with a clean stalte, we can't be sure
//    that the standard libraries have been compiled, so
//    we start with these
export var brewFile = (filePath) => {
  var coffeeCode, firstLine, getLine, hMetaData, js, jsPath, lLines, lYaml, line, mapPath, nReader, shebang, v3SourceMap;
  jsPath = withExt(filePath, '.js');
  mapPath = withExt(filePath, '.js.map');
  if (newerDestFilesExist(filePath, jsPath, mapPath)) {
    return;
  }
  // --- define getLine() to read line by line
  nReader = new NReadLines(filePath);
  getLine = () => {
    var buffer, result;
    buffer = nReader.next();
    if (buffer === false) {
      nReader = undef; // prevent further reads
      return undef;
    }
    result = buffer.toString().replaceAll('\r', '');
    if (result === '__END__') {
      return undef;
    }
    return result;
  };
  firstLine = getLine();
  shebang = undef;
  // --- fetch any metadata
  if (firstLine === '---') {
    lYaml = [];
    line = getLine();
    while (line !== '---') {
      lYaml.push(line);
      line = getLine();
    }
    hMetaData = YAML.parse(lYaml.join("\n"));
    shebang = hMetaData.shebang;
    if (shebang === true) {
      shebang = "#!/usr/bin/env node";
    }
  }
  if (firstLine === '---') {
    lLines = [];
  } else {
    lLines = [firstLine];
  }
  line = getLine();
  while ((line !== undef) && (line !== '__END__')) {
    lLines.push(line);
    line = getLine();
  }
  coffeeCode = lLines.join("\n");
  ({js, v3SourceMap} = CoffeeScript.compile(coffeeCode, {
    bare: true,
    header: false,
    sourceMap: true,
    filename: filePath
  }));
  if (shebang === undef) {
    fs.writeFileSync(jsPath, js);
  } else {
    fs.writeFileSync(jsPath, shebang + "\n" + js);
  }
  fs.writeFileSync(mapPath, v3SourceMap);
  console.log(filePath.replaceAll('\\', '/'));
};

// ---------------------------------------------------------------------------
export var fileExt = (filePath) => {
  var lMatches;
  if (lMatches = filePath.match(/\.[^\.]+$/)) {
    return lMatches[0];
  } else {
    return '';
  }
};

// ---------------------------------------------------------------------------
export var withExt = (filePath, newExt) => {
  var _, lMatches, pre;
  if (newExt.indexOf('.') !== 0) {
    newExt = '.' + newExt;
  }
  if (lMatches = filePath.match(/^(.*)\.[^\.]+$/)) {
    [_, pre] = lMatches;
    return pre + newExt;
  }
  throw new Error(`Bad path: '${filePath}'`);
};

// ---------------------------------------------------------------------------
export var newerDestFilesExist = (srcPath, ...lDestPaths) => {
  var destModTime, destPath, i, len, srcModTime;
  for (i = 0, len = lDestPaths.length; i < len; i++) {
    destPath = lDestPaths[i];
    if (!fs.existsSync(destPath)) {
      return false;
    }
    srcModTime = fs.statSync(srcPath).mtimeMs;
    destModTime = fs.statSync(destPath).mtimeMs;
    if (destModTime < srcModTime) {
      return false;
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var execCmd = (cmdLine) => {
  execSync(cmdLine, {
    encoding: 'utf8',
    windowsHide: true
  });
};

// ---------------------------------------------------------------------------
// --- convert \ to /
//     convert "C:..." to "c:..."
export var normalize = (filePath) => {
  filePath = filePath.replaceAll('\\', '/');
  if (filePath.charAt(1) === ':') {
    return filePath.charAt(0).toLowerCase() + filePath.substring(1);
  } else {
    return filePath;
  }
};

// ---------------------------------------------------------------------------
export var isFakeFile = (filePath) => {
  return false;
};

// ---------------------------------------------------------------------------
export var createFakeFiles = () => {
  var destPath, filePath, i, len, ref;
  ref = globSync('./src/{bin,lib}/*.peggy');
  for (i = 0, len = ref.length; i < len; i++) {
    filePath = ref[i];
    destPath = withExt(filePath, '.js');
    if (!fs.existsSync(destPath)) {
      console.log(normalize(destPath) + ' (fake)');
      fs.writeFileSync(destPath, `// fake
export function parse(str) {
	throw new Error("Attempt to use fake peggy file ${destPath}");
	}`);
    }
  }
};
