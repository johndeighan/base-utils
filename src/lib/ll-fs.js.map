{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "src\\lib\\ll-fs.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# ll-fs.coffee\n\nimport pathLib from 'node:path'\nimport urlLib from 'url'\nimport fs from 'fs'\nimport {globSync as glob} from 'glob'\n\nimport {\n\tpass, undef, defined, notdefined,\n\tisString, getOptions, words,\n\tfileExt, withExt, newerDestFilesExist,\n\tassert, croak,                  # low level versions\n\t} from '@jdeighan/base-utils'\n\nexport {\n\tfileExt, withExt, newerDestFilesExist,\n\t}\n\nexport lStatFields = words(\n\t'dev ino mode nlink uid gid rdev size blksize blocks',\n\t'atimeMs mtimeMs ctimeMs birthtimeMs',\n\t'atime mtime ctime birthtime',\n\t)\n\n# ---------------------------------------------------------------------------\n# All file/directory operations should operate from memory\n#    and can therefore be synchronous\n# Relies on the fact that modern OS's keep directory\n#    information in memory\n# ---------------------------------------------------------------------------\n\nexport fileDirPath = (filePath) =>\n\t# --- file does not need to exist yet, but\n\t#     it should be a file path\n\n\tassert isString(filePath), \"not a string: '#{filePath}'\"\n\tfullPath = mkpath(filePath)\n\thFile = parsePath(fullPath)\n\tdirStr = hFile.dir\n\trootLen = hFile.root.length\n\tlParts = dirStr.substring(rootLen).split(/[\\\\\\/]/)\n\treturn [hFile.root, lParts]\n\n# ---------------------------------------------------------------------------\n\nexport mkDirsForFile = (filePath) =>\n\n\t[root, lParts] = fileDirPath(filePath)\n\tdir = root\n\tfor part in lParts\n\t\tdir = \"#{dir}/#{part}\"\n\t\tif ! isDir(dir)\n\t\t\tmkDir(dir)\n\treturn\n\n# ---------------------------------------------------------------------------\n#     convert \\ to /\n# --- convert \"C:...\" to \"c:...\"\n\nnormalize = (path) =>\n\n\tpath = path.replaceAll '\\\\', '/'\n\tif (path.charAt(1) == ':')\n\t\treturn path.charAt(0).toLowerCase() + path.substring(1)\n\telse\n\t\treturn path\n\n# ---------------------------------------------------------------------------\n\nexport workingDir = () ->\n\n\treturn normalize process.cwd()\n\n# ---------------------------------------------------------------------------\n# --- Should be called like: myself(import.meta.url)\n#     returns full path of current file\n\nexport myself = (url) =>\n\n\tpath = urlLib.fileURLToPath url\n\treturn normalize path\n\n# ---------------------------------------------------------------------------\n# --- Should be called like: mydir(import.meta.url)\n#     returns the directory that the current file is in\n\nexport mydir = (url) =>\n\n\tpath = urlLib.fileURLToPath url\n\tdir = pathLib.dirname path\n\treturn normalize dir\n\n# ---------------------------------------------------------------------------\n\nexport mkpath = (lParts...) =>\n\n\tfullPath = pathLib.resolve lParts...\n\treturn normalize fullPath\n\n# ---------------------------------------------------------------------------\n\nexport samefile = (path1, path2) =>\n\n\treturn (mkpath(path1) == mkpath(path2))\n\n# ---------------------------------------------------------------------------\n\nexport relpath = (lParts...) =>\n\n\tfullPath = pathLib.resolve lParts...\n\treturn normalize pathLib.relative('', fullPath)\n\n# ---------------------------------------------------------------------------\n# --- returned hash has keys:\n#\n#  dev: 2114,\n#  ino: 48064969,\n#  mode: 33188,\n#  nlink: 1,\n#  uid: 85,\n#  gid: 100,\n#  rdev: 0,\n#  size: 527,\n#  blksize: 4096,\n#  blocks: 8,\n#  atimeMs: 1318289051000.1,\n#  mtimeMs: 1318289051000.1,\n#  ctimeMs: 1318289051000.1,\n#  birthtimeMs: 1318289051000.1,\n#  atime: Mon, 10 Oct 2011 23:24:11 GMT,\n#  mtime: Mon, 10 Oct 2011 23:24:11 GMT,\n#  ctime: Mon, 10 Oct 2011 23:24:11 GMT,\n#  birthtime: Mon, 10 Oct 2011 23:24:11 GMT\n\nexport getFileStats = (path) =>\n\n\treturn fs.lstatSync(path)\n\n# ---------------------------------------------------------------------------\n# --- Since a disk's directory is kept in memory,\n#     directory operations can be done synchronously\n\nexport isDir = (dirPath) =>\n\n\tif ! fs.existsSync(dirPath)\n\t\treturn false\n\ttry\n\t\treturn getFileStats(dirPath).isDirectory()\n\tcatch\n\t\treturn false\n\n# ---------------------------------------------------------------------------\n\nexport mkDir = (dirPath, hOptions={}) =>\n\n\thOptions = getOptions hOptions, {\n\t\tclear: false\n\t\t}\n\ttry\n\t\tfs.mkdirSync dirPath\n\t\treturn true\n\tcatch err\n\t\tif (err.code == 'EEXIST')\n\t\t\tif hOptions.clear\n\t\t\t\tclearDir dirPath\n\t\t\treturn false\n\t\telse\n\t\t\tthrow err\n\n# ---------------------------------------------------------------------------\n\nexport dirContents = (dirPath, hOptions={}) ->\n\n\t{filesOnly, dirsOnly, regexp} = getOptions hOptions, {\n\t\tfilesOnly: false\n\t\tdirsOnly: false\n\t\tregexp: undef\n\t\t}\n\tassert ! (filesOnly && dirsOnly), \"Incompatible options\"\n\n\th = {withFileTypes: true, recursive: false}\n\tfor ent in fs.readdirSync(dirPath, h)\n\t\tname = ent.name\n\t\tif ent.isFile()\n\t\t\tif !dirsOnly\n\t\t\t\tif notdefined(regexp) || regexp.test(name)\n\t\t\t\t\tyield name\n\t\telse if ent.isDirectory()\n\t\t\tif !filesOnly\n\t\t\t\tif notdefined(regexp) || regexp.test(name)\n\t\t\t\t\tyield name\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport dirListing = (dirPath, hOptions={}) =>\n\n\treturn Array.from(dirContents(dirPath, hOptions))\n\n# ---------------------------------------------------------------------------\n\nexport clearDir = (dirPath) =>\n\n\ttry\n\t\thOptions = {withFileTypes: true, recursive: true}\n\t\tfor ent in fs.readdirSync(dirPath, hOptions)\n\t\t\tif ent.isFile()\n\t\t\t\tfs.rmSync mkpath(ent.path, ent.name)\n\tcatch err\n\t\tpass()\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport rmDir = (dirPath, recursive=true) =>\n\n\tassert isDir(dirPath), \"#{dirPath} is not a directory\"\n\tfs.rmSync dirPath, {recursive}\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport touch = (filePath) =>\n\n\tfd = fs.openSync(filePath, 'a')\n\tfs.closeSync(fd)\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport isFile = (filePath) =>\n\n\tif ! fs.existsSync(filePath)\n\t\treturn false\n\ttry\n\t\treturn getFileStats(filePath).isFile()\n\tcatch\n\t\treturn false\n\n# ---------------------------------------------------------------------------\n\nexport rename = (oldPath, newPath) =>\n\n\tfs.renameSync oldPath, newPath\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport rmFile = (filePath) =>\n\n\tassert isFile(filePath), \"#{filePath} is not a file\"\n\tfs.rmSync filePath\n\treturn\n\n# ---------------------------------------------------------------------------\n# --- returns one of:\n#        'missing'  - does not exist\n#        'dir'      - is a directory\n#        'file'     - is a file\n#        'unknown'  - exists, but not a file or directory\n\nexport pathType = (fullPath) =>\n\n\tassert isString(fullPath), \"not a string\"\n\tif fs.existsSync fullPath\n\t\tif isFile fullPath\n\t\t\treturn 'file'\n\t\telse if isDir fullPath\n\t\t\treturn 'dir'\n\t\telse\n\t\t\treturn 'unknown'\n\telse\n\t\treturn 'missing'\n\n# ---------------------------------------------------------------------------\n\nexport parsePath = (path) =>\n\t# --- NOTE: path may be a file URL, e.g. import.meta.url\n\t#           path may be a relative path\n\n\tassert isString(path), \"path is type #{typeof path}\"\n\n\tif path.match(/^file\\:\\/\\//)\n\t\tpath = normalize urlLib.fileURLToPath(path)\n\telse\n\t\t# --- handles relative paths\n\t\tpath = normalize pathLib.resolve(path)\n\ttype = pathType path\n\n\t{root, dir, base, name, ext} = pathLib.parse(path)\n\tif lMatches = name.match(///\n\t\t\t\\.\n\t\t\t([A-Za-z_]+)\n\t\t\t$///)\n\t\tpurpose = lMatches[1]\n\telse\n\t\tpurpose = undef\n\thFile = {\n\t\tpath\n\t\tfilePath: path\n\t\ttype\n\t\troot\n\t\tdir\n\t\tbase\n\t\tfileName: base   # my preferred name\n\t\tname             # use this for directory name\n\t\tstub: name       # my preferred name\n\t\text\n\t\tpurpose\n\t\t}\n\tif isFile(path)\n\t\tObject.assign hFile, getFileStats(path)\n\treturn hFile\n\n# ---------------------------------------------------------------------------\n\nexport parentDir = (path) =>\n\n\thParsed = parsePath(path)\n\treturn hParsed.dir\n\n# ---------------------------------------------------------------------------\n\nexport parallelPath = (path, name=\"temp\") =>\n\n\tfullPath = mkpath(path)  # make full path with '/' as separator\n\t{dir, fileName} = parsePath fullPath\n\tif (lMatches = dir.match(///^\n\t\t\t(.*)\n\t\t\t\\/         # separator\n\t\t\t[^\\/]+     # final dir name\n\t\t\t$///))\n\t\t[_, subpath] = lMatches\n\t\treturn \"#{subpath}/#{name}/#{fileName}\"\n\telse\n\t\tcroak \"Can't get parallelPath for '#{path}'\"\n\n# ---------------------------------------------------------------------------\n\nexport subPath = (path, name=\"temp\") =>\n\n\tfullPath = mkpath(path)  # make full path with '/' as separator\n\t{dir, fileName} = parsePath fullPath\n\treturn \"#{dir}/#{name}/#{fileName}\""
  ]
}