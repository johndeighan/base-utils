{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "src\\lib\\parse-cmd-args.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# parse-cmd-args.coffee\n\nimport {\n\tundef, defined, notdefined, getOptions,\n\tOL, hasKey, words,\n\tisHash, isArray, isNumber, isInteger, isRegExp,\n\tisString, isBoolean,\n\t} from '@jdeighan/base-utils'\nimport {LOG} from '@jdeighan/base-utils/log'\nimport {\n\tdbgEnter, dbgReturn, dbg, debugDebug,\n\t} from '@jdeighan/base-utils/debug'\nimport {\n\tassert, croak,\n\t} from '@jdeighan/base-utils/exceptions'\nimport {parse} from '@jdeighan/base-utils/cmd-args'\nimport {pparse} from '@jdeighan/base-utils/peggy'\n\nlTypes = words('boolean string number integer json')\n\n# ---------------------------------------------------------------------------\n\nexport argStrFromArgv = () =>\n\n\tdbgEnter 'argStrFromArgv'\n\tlTrueArgs = process.argv.slice(2)\n\tdbg 'lTrueArgs', lTrueArgs\n\tlQuoted = lTrueArgs.map((str) =>\n\t\tif str.match(/\\s/)\n\t\t\tif lMatches=str.match(///^\n\t\t\t\t\t\\-\n\t\t\t\t\t([A-Za-z_][A-Za-z0-9_]+)\n\t\t\t\t\t\\=\n\t\t\t\t\t(.*)\n\t\t\t\t\t$///)\n\t\t\t\t[_, name, value] = lMatches\n\t\t\t\treturn \"-#{name}=\\\"#{value}\\\"\"\n\t\t\telse\n\t\t\t\treturn '\"' + str + '\"'\n\t\telse\n\t\t\treturn str\n\t\t)\n\tdbg 'lQuoted', lQuoted\n\tresult = lQuoted.join(' ')\n\tdbgReturn 'argStrFromArgv', result\n\treturn result\n\n# ---------------------------------------------------------------------------\n# --- option 'expect' should be a hash, like:\n#        {\n#           <name>: <type>\n#           _: [<int>, <int>]  # min, max\n#           }\n#        <type> can be:\n#           a regular expression # --- implies value is a string\n#           'boolean'\n#           'string'\n#           'number'\n#           'integer'\n#           'json'\n\nexport parseCmdArgs = (hOptions={}) =>\n\n\tdbgEnter 'parseCmdArgs', hOptions\n\t{argStr, hExpect} = getOptions hOptions, {\n\t\targStr: undef\n\t\thExpect: undef\n\t\t}\n\n\t# --- Check if hExpect option is valid\n\tminNonOptions = 0\n\tmaxNonOptions = Infinity\n\tif defined(hExpect)\n\t\tassert isHash(hExpect), \"hExpect is not a hash\"\n\t\tfor own key,value of hExpect\n\t\t\tif (key == '_')\n\t\t\t\tassert isArray(value), \"key '_', value = #{OL(value)}\"\n\t\t\t\tassert (value.length == 2), \"Bad '_' key\"\n\t\t\t\t[min, max] = value\n\t\t\t\tif defined(min)\n\t\t\t\t\tassert isInteger(min, {min:0}), \"Bad '_' key, min = #{OL(min)}\"\n\t\t\t\t\tminNonOptions = min\n\t\t\t\tif defined(max)\n\t\t\t\t\tassert isInteger(max, {min:0}), \"Bad '_' key, max = #{OL(max)}\"\n\t\t\t\t\tmaxNonOptions = max\n\t\t\t\t\tif defined(min)\n\t\t\t\t\t\tassert (min <= max), \"min = #{OL(min)}, max = #{OL(max)}\"\n\t\t\telse\n\t\t\t\tassert lTypes.includes(value) || isRegExp(value),\n\t\t\t\t\t\t\"Bad type for #{key}: #{OL(value)}\"\n\n\tif notdefined(argStr)\n\t\targStr = argStrFromArgv()\n\tdbg \"arg str = '#{argStr}'\"\n\n\thResult = pparse(parse, argStr)\n\tdbg 'hResult', hResult\n\tassert isHash(hResult), \"hResult = #{OL(hResult)}\"\n\n\tif hasKey(hResult, '_')\n\t\tnumNonOptions = hResult._.length\n\telse\n\t\tnumNonOptions = 0\n\n\tassert numNonOptions >= minNonOptions,\n\t\t\t\"#{numNonOptions} non options < min #{min}\",\n\t\t\thResult, 'hResult'\n\tassert numNonOptions <= maxNonOptions,\n\t\t\t\"#{numNonOptions} non options > max #{max}\",\n\t\t\thResult, 'hResult'\n\n\tfor own name,value of hResult\n\t\tdbg \"FOUND #{name} = #{OL(value)}\"\n\t\tif (name == '_')\n\t\t\tcontinue\n\t\telse if isBoolean(value)\n\t\t\tif defined(hExpect)\n\t\t\t\tassert (hExpect[name] == 'boolean'),\n\t\t\t\t\t\t\"boolean #{name} not expected\"\n\t\telse\n\t\t\tassert isString(value), \"value = #{OL(value)}\"\n\t\t\tif defined(hExpect)\n\t\t\t\ttype = hExpect[name]\n\t\t\t\tassert defined(type), \"Unexpected option: #{OL(name)}\"\n\t\t\t\tif isRegExp(type)\n\t\t\t\t\tassert value.match(type),\n\t\t\t\t\t\t\t\"Bad value for option -#{name}: #{OL(value)}\"\n\t\t\t\t\thResult[name] = value\n\t\t\t\telse\n\t\t\t\t\thResult[name] = getVal(name, type, value)\n\n\tdbgReturn 'parseCmdArgs', hResult\n\treturn hResult\n\n# ---------------------------------------------------------------------------\n\nexport getVal = (name, type, value) =>\n\n\tswitch type\n\t\twhen 'boolean'\n\t\t\tif isBoolean(value)\n\t\t\t\treturn value\n\t\t\telse if (value == 'true')\n\t\t\t\treturn true\n\t\t\telse if (value == 'false')\n\t\t\t\treturn false\n\t\t\telse\n\t\t\t\tcroak \"#{name} should be 'true' or 'false' (#{OL(value)})\"\n\t\twhen 'string'\n\t\t\treturn value\n\t\twhen 'number'\n\t\t\tif value.match(/^\\d+(\\.\\d*)$/)\n\t\t\t\treturn Number(value)\n\t\t\telse\n\t\t\t\tcroak \"option #{name} not a number\"\n\t\twhen 'integer'\n\t\t\tif value.match(/^\\d+$/)\n\t\t\t\treturn parseInt(value)\n\t\t\telse\n\t\t\t\tcroak \"option #{name} not an integer\"\n\t\twhen 'json'\n\t\t\treturn JSON.parse(value)\n\treturn"
  ]
}