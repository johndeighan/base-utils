{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "src\\lib\\peggy.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# peggy.coffee\n\nimport peggy from 'peggy'\n\nimport {\n\tundef, defined, notdefined, pass, OL, getOptions, hasKey,\n\tisString, isFunction, isArray, isHash, isEmpty, nonEmpty,\n\ttoArray, toBlock, isArrayOfStrings, removeEmptyLines,\n\tisNonEmptyString, untabify, centeredText,\n\t} from '@jdeighan/base-utils'\nimport {LOG} from '@jdeighan/base-utils/log'\nimport {assert, croak} from '@jdeighan/base-utils/exceptions'\nimport {dbgEnter, dbgReturn, dbg} from '@jdeighan/base-utils/debug'\nimport {\n\tisIndented, undented, splitLine, indentLevel, indented,\n\t} from '@jdeighan/base-utils/indent'\nimport {\n\tisFile, slurp, barf, withExt,\n\t} from '@jdeighan/base-utils/fs'\nimport {\n\treadTextFile, getShebang,\n\t} from '@jdeighan/base-utils/read-file'\nimport {brew} from '@jdeighan/base-utils/coffee'\n\nhCodePreProcessors = {\n\tcoffee: (code) =>\n\t\t[jsCode, _] = brew code\n\t\treturn jsCode\n\tjavascript: (code) =>\n\t\treturn code\n\t}\n\n# ---------------------------------------------------------------------------\n\nexport addCodePreProcessor = (name, func) =>\n\n\tassert isNonEmptyString(name), \"Bad name: #{OL(name)}\"\n\tassert ! hasKey(hCodePreProcessors, name), \"Exists: #{OL(name)}\"\n\tassert isFunction(func), \"Not a function: #{OL(func)}\"\n\thCodePreProcessors[name] = func\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport peggifyFile = (filePath) =>\n\n\tdbgEnter 'peggifyFile', filePath\n\t[hMetaData, lLines] = readTextFile(filePath, 'eager')\n\tassert isArray(lLines), \"Bad return from readTextFile\"\n\tdbg 'hMetaData', hMetaData\n\t[jsCode, sourceMap] = peggify lLines, {\n\t\tsource: filePath\n\t\thMetaData\n\t\t}\n\tbarf jsCode, withExt(filePath, '.js')\n\tif defined(sourceMap)\n\t\tbarf sourceMap, withExt(filePath, '.js.map')\n\tdbgReturn 'peggifyFile'\n\treturn\n\n# ---------------------------------------------------------------------------\n# --- peggyCode can be a string or array of strings\n#     Valid options:\n#        source - relative or absolute path to source file\n#        type - usually 'coffee', may also appear in hMetaData\n#        hMetaData\n#           - may contain key 'type' (usually 'coffee')\n#           - may contain key 'shebang' (usually true)\n\nexport peggify = (peggyCode, hOptions) =>\n\n\tdbgEnter 'peggify', peggyCode, hOptions\n\t{source, type, hMetaData} = getOptions hOptions, {\n\t\tsource: undef\n\t\ttype: undef\n\t\thMetaData: {}\n\t\t}\n\n\tassert isHash(hMetaData), \"hMetaData not a hash: #{OL(hMetaData)}\"\n\n\t# --- determine type, if any\n\tif defined(type)\n\t\tassert notdefined(hMetaData.type) || (hMetaData.type == type),\n\t\t\t\"Conflicting types\"\n\telse if defined(hMetaData.type)\n\t\ttype = hMetaData.type\n\tdbg \"type = #{OL(type)}\"\n\n\t# --- preprocess peggyCode if required\n\t#        - ensure peggyCode ends up as a string\n\n\tif defined(type)\n\t\tif isString(peggyCode)\n\t\t\tpeggyCode = convertToJS(toArray(peggyCode), type, hMetaData)\n\t\telse if isArrayOfStrings(peggyCode)\n\t\t\tpeggyCode = convertToJS(peggyCode, type, hMetaData)\n\t\telse\n\t\t\tcroak \"Bad peggy code\"\n\t\tdbg \"JSified peggy code\", peggyCode\n\telse if isArray(peggyCode)\n\t\tpeggyCode = toBlock(peggyCode)\n\ttry\n\t\tif defined(source)\n\t\t\tassert isFile(source), \"Not a file: #{OL(source)}\"\n\t\t\tsrcNode = peggy.generate(peggyCode, {\n\t\t\t\tgrammarSource: source\n\t\t\t\tallowedStartRules: ['*']\n\t\t\t\tformat: 'es'\n\t\t\t\toutput: 'source-and-map'\n\t\t\t\ttrace: true   # compile w/tracing capability\n\t\t\t\t})\n\t\t\th = srcNode.toStringWithSourceMap()\n\t\t\tjsCode = h.code\n\t\t\tsrcMap = h.map.toString()\n\t\telse\n\t\t\tjsCode = peggy.generate(peggyCode, {\n\t\t\t\tallowedStartRules: ['*']\n\t\t\t\tformat: 'es'\n\t\t\t\toutput: 'source'\n\t\t\t\ttrace: true   # compile w/tracing capability\n\t\t\t\t})\n\t\t\tsrcMap = undef\n\n\t\tshebang = getShebang(hMetaData)\n\t\tif defined(shebang)\n\t\t\tjsCode = shebang + \"\\n\" + jsCode\n\n\t\tresult = [jsCode, srcMap]\n\n\tcatch err\n\t\tconsole.log centeredText('peggy generate failed', 74, 'char=-')\n\t\tconsole.log untabify(peggyCode)\n\t\tconsole.log '-'.repeat(74)\n\t\tthrow err\n\n\tdbgReturn 'peggify', result\n\treturn result\n\n# ---------------------------------------------------------------------------\n\nexport convertCodeToJS = (code, type) =>\n\n\tdbgEnter 'convertCodeToJS', code, type\n\tcode = toBlock(code)\n\ttry\n\t\tjsCode = hCodePreProcessors[type](code)\n\tcatch err\n\t\tconsole.log \"ERROR: Unable to convert #{type} code to JS\"\n\t\tconsole.log '-'.repeat(40)\n\t\tconsole.log code\n\t\tconsole.log '-'.repeat(40)\n\t\tjsCode = ''\n\tdbgReturn 'convertCodeToJS', jsCode\n\treturn jsCode\n\n# ---------------------------------------------------------------------------\n# --- input may be a string or array of strings\n# --- returns a block of JavaScript code\n\nexport convertToJS = (lLines, type, hMetaData) =>\n\n\tdbgEnter 'convertToJS', lLines, type, hMetaData\n\tassert isArray(lLines), \"lLines = #{OL(lLines)}\"\n\tassert isHash(hMetaData), \"Not a hash: #{OL(hMetaData)}\"\n\n\tlLines = removeEmptyLines(lLines)\n\n\tassert isArrayOfStrings(lLines),\n\t\t\t\"not an array of strings: #{OL(lLines)}\"\n\n\t# --- NOTE: There are NO empty lines in lLines !!!\n\t#     We will remove lines from lLines as they're processed\n\n\tassert isFunction(hCodePreProcessors[type]),\n\t\t\t\"Unknown type: #{OL(type)}\"\n\n\t# --- Define some utility functions -----------------\n\n\t# --- are there more lines to process?\n\tmore = () =>\n\t\treturn (lLines.length > 0)\n\n\t# --- what is the next line?\n\tnext = () =>\n\t\treturn lLines[0]\n\n\t# --- what is the level of the next line?\n\tnextLevel = () =>\n\t\tif (next() == undef)\n\t\t\treturn 0\n\t\treturn indentLevel(lLines[0])\n\n\t# --- get the next line, removing it from lLines\n\tget = () =>\n\t\treturn lLines.shift()\n\n\t# --- remove the next line without returning it\n\tskip = () =>\n\t\tlLines.shift()\n\t\treturn\n\n\t# --- get a block of code, as an array, undented\n\tgetCodeLines = (minLevel) =>\n\t\tdbgEnter 'getCodeLines', minLevel\n\t\tlCodeLines = []\n\t\twhile (nextLevel() >= minLevel)\n\t\t\tlCodeLines.push get()\n\t\tresult = undented(lCodeLines)\n\t\tdbgReturn 'getCodeLines', result\n\t\treturn result\n\n\t# --------------------------------------------\n\n\tlPeggy = []   # --- shift lines from lLines as processed\n\n\tif (next() == 'INITIALIZATION')\n\t\tskip()\n\t\tdbg \"Found INITIALIZATION section\"\n\t\tlCode = getCodeLines(1)\n\t\tjsCode = convertCodeToJS(lCode, type)\n\t\tlPeggy.push \"{{\"\n\t\tlPeggy.push jsCode\n\t\tlPeggy.push \"}}\"\n\n\tif (next() == 'EACH_PARSE')\n\t\tskip()\n\t\tdbg \"Found EACH_PARSE section\"\n\t\tlCode = getCodeLines(1)\n\t\tjsCode = convertCodeToJS(lCode, type)\n\t\tlPeggy.push \"{\"\n\t\tlPeggy.push jsCode\n\t\tlPeggy.push \"}\"\n\n\thRules = {}\n\twhile more()\n\n\t\t# --- Get rule name - must be left aligned, no whitespace\n\t\tname = get()\n\t\tlPeggy.push name\n\t\tdbg \"RULE #{OL(name)}\"\n\t\tassert !name.match(/\\s/), \"whitespace in rule name #{OL(name)}\"\n\t\tassert !hasKey(hRules, name), \"duplicate rule #{name}\"\n\t\thRules[name] = 0   # number of options\n\n\t\twhile more() && (nextLevel() == 1)\n\t\t\t# --- Get match expression - 1 indent level, may be multi-line\n\t\t\tlExprLines = []\n\t\t\twhile (nextLevel() == 1)\n\t\t\t\tlExprLines.push get().trim()\n\t\t\tassert (lExprLines.length > 0), \"Bad rule #{name}\"\n\t\t\tmatchExpr = lExprLines.join(' ')\n\n\t\t\tch = if (hRules[name] == 0) then '=' else '/'\n\t\t\theaderLine = \"#{ch} #{matchExpr}\"\n\t\t\tdbg \"\"\n\t\t\tdbg \"OPTION #{hRules[name]}\", headerLine\n\t\t\tlPeggy.push \"  #{headerLine}\"\n\t\t\thRules[name] += 1\n\n\t\t\tlCode = getCodeLines(2)\n\t\t\tif nonEmpty(lCode)\n\t\t\t\tjsCode = convertCodeToJS(lCode, type)\n\t\t\t\tlPeggy.push \"    {\"\n\t\t\t\tlPeggy.push indented(jsCode, 2, \"  \")\n\t\t\t\tlPeggy.push \"    }\"\n\t\t\t\tlPeggy.push \"\"\n\n\tresult = toBlock(lPeggy)\n\tdbgReturn 'convertToJS', result\n\treturn result\n\n# ---------------------------------------------------------------------------\n\n# --- Tracer object does not log\n\nclass Tracer\n\n\ttrace: ({type, rule, location}) ->\n\t\tpass()\n\nclass MyTracer extends Tracer\n\n\tconstructor: () ->\n\t\tsuper()\n\t\t@level = 0\n\n\tprefix: () ->\n\t\treturn \"|  \".repeat(@level)\n\n\ttrace: ({type, rule, location, match}) ->\n\t\tswitch type\n\t\t\twhen 'rule.enter'\n\t\t\t\tconsole.log \"#{@prefix()}? #{rule}\"\n\t\t\t\t@level += 1\n\t\t\twhen 'rule.fail'\n\t\t\t\t@level -= 1;\n\t\t\t\tconsole.log \"#{@prefix()}NO\"\n\t\t\twhen 'rule.match'\n\t\t\t\t@level -= 1\n\t\t\t\tif defined(match)\n\t\t\t\t\tconsole.log \"#{@prefix()}YES - #{OL(match)}\"\n\t\t\t\telse\n\t\t\t\t\tconsole.log \"#{@prefix()}YES\"\n\t\t\telse\n\t\t\t\tconsole.log \"UNKNOWN type: #{type}\"\n\t\treturn\n\n# ---------------------------------------------------------------------------\n\nexport pparse = (parseFunc, inputStr, hOptions={}) =>\n\n\tdbgEnter 'pparse', 'FUNC', inputStr, hOptions\n\n\t{start, tracer} = getOptions hOptions, {\n\t\tstart: undef     #     name of start rule\n\t\ttracer: 'none'   # --- can be none/peggy/default/a function\n\t\t}\n\n\tdbg \"tracer = #{OL(tracer)}\"\n\n\thParseOptions = {}\n\tif defined(start)\n\t\thParseOptions.startRule = start\n\tswitch tracer\n\t\twhen 'none'\n\t\t\thParseOptions.tracer = new Tracer()\n\t\twhen 'peggy'\n\t\t\tpass()\n\t\twhen 'default'\n\t\t\thParseOptions.tracer = new MyTracer()\n\t\telse\n\t\t\tassert isFunction(tracer), \"tracer not a function\"\n\t\t\thParseOptions.tracer = tracer\n\n\tresult = parseFunc(inputStr, hParseOptions)\n\tdbgReturn 'pparse', result\n\treturn result"
  ]
}