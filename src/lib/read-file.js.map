{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "src\\lib\\read-file.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# read-file.coffee\n\nimport pathLib from 'node:path'\nimport NReadLines from 'n-readlines'\nimport {globSync as glob} from 'glob'\n\nimport {\n\tundef, defined, notdefined, OL, getOptions, isFunction,\n\tisArray, isString, isRegExp, isEmpty, isIterable,\n\t} from '@jdeighan/base-utils'\nimport {\n\tassert, croak,\n\t} from '@jdeighan/base-utils/exceptions'\nimport {LOG, LOGVALUE} from '@jdeighan/base-utils/log'\nimport {\n\tdbgEnter, dbgReturn, dbg, dbgYield, dbgResume,\n\t} from '@jdeighan/base-utils/debug'\nimport {\n\tisFile, mkpath, relpath, lStatFields,\n\t} from '@jdeighan/base-utils/fs'\nimport {\n\tisMetaDataStart, convertMetaData,\n\t} from '@jdeighan/base-utils/metadata'\n\n# ---------------------------------------------------------------------------\n# --- Valid options:\n#        eager - if true, return lLines in place of reader\n#        pattern - string or regexp lines must match\n#        transform - function to apply to lines\n\nexport readTextFile = (source, hOptions={}) =>\n\t# --- handles metadata if present\n\t#     source should be either:\n\t#        - a file path\n\t#        - an iterable\n\n\tdbgEnter 'readTextFile', source\n\tif isString(source)\n\t\tassert isFile(source), \"Not a file: #{OL(source)}\"\n\t\tfilePath = source\n\telse if isIterable(source)\n\t\t# --- it has key [Symbol.iterator],\n\t\t#     which is a function\n\t\titerator = source[Symbol.iterator]()\n\telse\n\t\tcroak \"Not a file or iterable: #{OL(source)}\"\n\n\t{eager, pattern, transform} = getOptions(\n\t\thOptions, {\n\t\t\teager: false\n\t\t\tpattern: undef\n\t\t\ttransform: undef\n\t\t\t})\n\n\tdbg 'eager', eager\n\tdbg 'pattern', pattern\n\tdbg 'transform', transform\n\n\t# --- define an appropriate lineMatches function\n\tif defined(pattern)\n\t\tif isString(pattern)\n\t\t\tlineMatches = (line) => return line.includes(pattern)\n\t\telse if isRegExp(pattern)\n\t\t\tlineMatches = (line) => return defined(line.match(pattern))\n\t\telse\n\t\t\tcroak \"Bad pattern option\"\n\telse\n\t\tlineMatches = (line) => return true\n\n\tinExtra = false\n\tif defined(filePath)\n\t\tnReader = new NReadLines(filePath)\n\t\tgetLine = () =>\n\t\t\tbuffer = nReader.next()\n\t\t\tif (buffer == false)\n\t\t\t\tnReader = undef   # prevent further reads\n\t\t\t\treturn undef\n\t\t\tresult = buffer.toString().replaceAll('\\r', '')\n\t\t\tif (result == '__END__')\n\t\t\t\tinExtra = true\n\t\t\t\treturn undef\n\t\t\tdbg \"   getLine():  #{OL(result)}\"\n\t\t\treturn result\n\telse\n\t\tgetLine = () =>\n\t\t\t{value,done} = iterator.next()\n\t\t\tif done\n\t\t\t\titerator = undef   # prevent further reads\n\t\t\t\treturn undef\n\t\t\tresult = value || ''\n\t\t\tif (result == '__END__')\n\t\t\t\tinExtra = true\n\t\t\t\treturn undef\n\t\t\treturn result\n\n\t# --- we need to get the first line to check if\n\t#     there's metadata. But if there is not,\n\t#     we need to return it by the reader\n\tfirstLine = getLine()\n\tdbg 'firstLine', firstLine\n\n\tlMetaLines = undef\n\n\t# --- Get metadata if present\n\tif defined(firstLine) && isMetaDataStart(firstLine)\n\t\tdbg \"file has metadata: #{OL(firstLine)}\"\n\t\tlMetaLines = [firstLine]\n\t\ttempLine = getLine()\n\t\twhile tempLine && (tempLine != lMetaLines[0])\n\t\t\tlMetaLines.push tempLine\n\t\t\ttempLine = getLine()\n\t\thMetaData = convertMetaData(lMetaLines)\n\t\tdbg 'hMetaData', hMetaData\n\telse\n\t\tdbg \"file has no metadata\"\n\t\thMetaData = undef\n\n\tdbg 'lMetaLines', lMetaLines\n\tif defined(lMetaLines)\n\t\tnumLinesRead = lMetaLines.length + 1\n\telse\n\t\tnumLinesRead = 0\n\n\treader = () ->\n\t\t# --- NOTE lineMatches() returns true if empty pattern\n\n\t\tdbgEnter 'reader'\n\t\tif notdefined(hMetaData) \\\n\t\t\t\t&& !inExtra \\\n\t\t\t\t&& (matches = lineMatches(firstLine, pattern))\n\t\t\tdbg \"yielding first line because no metadata\"\n\t\t\tif defined(transform)\n\t\t\t\tresult = transform(firstLine)\n\t\t\telse\n\t\t\t\tresult = firstLine\n\t\t\tdbgYield 'reader', result\n\t\t\tyield result\n\t\t\tdbgResume 'reader'\n\t\tline = getLine()\n\t\twhile defined(line)\n\t\t\tif matches = lineMatches(line, pattern)\n\t\t\t\tif defined(transform) && !inExtra\n\t\t\t\t\tresult = transform(line)\n\t\t\t\telse\n\t\t\t\t\tresult = line\n\t\t\t\tdbgYield 'reader', result\n\t\t\t\tyield result\n\t\t\t\tdbgResume 'reader'\n\t\t\tline = getLine()\n\t\tdbgReturn 'reader'\n\t\treturn\n\n\tif eager\n\t\tresult = [\n\t\t\thMetaData || {}\n\t\t\tArray.from(reader())\n\t\t\tnumLinesRead\n\t\t\t]\n\telse\n\t\tresult = [\n\t\t\thMetaData || {}\n\t\t\treader\n\t\t\tnumLinesRead\n\t\t\t]\n\tdbgReturn 'readTextFile', result\n\treturn result\n\n# ---------------------------------------------------------------------------\n# --- yield hFile with keys:\n#        path, filePath\n#        type\n#        root\n#        dir\n#        base, fileName\n#        name, stub\n#        ext\n#        purpose\n#     ...plus stat fields\n\nexport globFiles = (pattern='*', hGlobOptions={}) ->\n\n\tdbgEnter 'globFiles', pattern, hGlobOptions\n\n\thGlobOptions = getOptions hGlobOptions, {\n\t\twithFileTypes: true\n\t\tstat: true\n\t\t}\n\n\tdbg 'pattern', pattern\n\tdbg 'hGlobOptions', hGlobOptions\n\n\tfor ent in glob(pattern, hGlobOptions)\n\t\tfilePath = mkpath(ent.fullpath())\n\t\t{root, dir, base, name, ext} = pathLib.parse(filePath)\n\t\tif lMatches = name.match(///\n\t\t\t\t\\.\n\t\t\t\t([A-Za-z_]+)\n\t\t\t\t$///)\n\t\t\tpurpose = lMatches[1]\n\t\telse\n\t\t\tpurpose = undef\n\t\tif ent.isDirectory()\n\t\t\ttype = 'dir'\n\t\telse if ent.isFile()\n\t\t\ttype = 'file'\n\t\telse\n\t\t\ttype = 'unknown'\n\t\thFile = {\n\t\t\tfilePath\n\t\t\tpath: filePath\n\t\t\trelPath: relpath(filePath)\n\t\t\ttype\n\t\t\troot\n\t\t\tdir\n\t\t\tbase\n\t\t\tfileName: base\n\t\t\tname\n\t\t\tstub: name\n\t\t\text\n\t\t\tpurpose\n\t\t\t}\n\t\tfor key in lStatFields\n\t\t\thFile[key] = ent[key]\n\t\tdbgYield 'globFiles', hFile\n\t\tyield hFile\n\t\tdbgResume 'globFiles'\n\n\tdbgReturn 'globFiles'\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport allFilesMatching = (pattern='*', hOptions={}) ->\n\t# --- yields hFile with keys:\n\t#        path, filePath,\n\t#        type, root, dir, base, fileName,\n\t#        name, stub, ext, purpose\n\t#        (if eager) hMetaData, lLines\n\t# --- Valid options:\n\t#        hGlobOptions - options to pass to glob\n\t#        fileFilter - return path iff fileFilter(filePath) returns true\n\t#        eager - read the file and add keys hMetaData, lLines\n\t# --- Valid glob options:\n\t#        ignore - glob pattern for files to ignore\n\t#        dot - include dot files/directories (default: false)\n\t#        cwd - change working directory\n\n\tdbgEnter 'allFilesMatching', pattern, hOptions\n\t{hGlobOptions, fileFilter, eager} = getOptions(hOptions, {\n\t\thGlobOptions: {\n\t\t\tignore: \"node_modules\"\n\t\t\t}\n\t\tfileFilter: (h) =>\n\t\t\t{filePath: path} = h\n\t\t\treturn isFile(path) && ! path.match(/\\bnode_modules\\b/i)\n\t\teager: false\n\t\t})\n\n\tdbg \"pattern = #{OL(pattern)}\"\n\tdbg \"hGlobOptions = #{OL(hGlobOptions)}\"\n\tdbg \"eager = #{OL(eager)}\"\n\n\tnumFiles = 0\n\tfor h from globFiles(pattern, hGlobOptions)\n\t\t{filePath} = h\n\t\tdbg \"GLOB: #{OL(filePath)}\"\n\t\tif eager && isFile(filePath)\n\t\t\t[hMetaData, lLines] = readTextFile(filePath, 'eager')\n\t\t\tassert isArray(lLines), \"Bad return from readTextFile\"\n\t\t\th.hMetaData = hMetaData\n\t\t\th.lLines = lLines\n\t\tif fileFilter(h)\n\t\t\tdbgYield 'allFilesMatching', h\n\t\t\tyield h\n\t\t\tdbgResume 'allFilesMatching'\n\t\t\tnumFiles += 1\n\tdbg \"#{numFiles} files matched\"\n\tdbgReturn 'allFilesMatching'\n\treturn\n\n# ---------------------------------------------------------------------------\n\nexport getShebang = (hMetaData) =>\n\n\tshebang = hMetaData.shebang\n\tif (shebang == true)\n\t\treturn \"#!/usr/bin/env node\"\n\telse if isString(shebang)\n\t\treturn shebang\n\telse if (isEmpty(shebang))\n\t\treturn undef\n\telse\n\t\tcroak \"Bad shebang: #{OL(shebang)}\""
  ]
}