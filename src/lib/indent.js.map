{
  "version": 3,
  "file": "indent.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\indent.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# indent.coffee\r\n\r\nimport {\r\n\tundef, defined, notdefined, toArray, toBlock, OL, rtrim,\r\n\tisInteger, isString, isArray, isEmpty, isArrayOfStrings,\r\n\t} from '@jdeighan/base-utils'\r\nimport {assert, croak} from '@jdeighan/base-utils/exceptions'\r\n\r\n# ---------------------------------------------------------------------------\r\n\r\nexport getOneIndent = (str) =>\r\n\r\n\tif (lMatches = str.match(/^\\t+(?:\\S|$)/))\r\n\t\treturn \"\\t\"\r\n\telse if (lMatches = str.match(/^(\\x20+)(?:\\S|$)/))   # space char\r\n\t\treturn lMatches[1]\r\n\tassert notdefined(str.match(/^\\s/)), \"Mixed indentation types\"\r\n\treturn undef\r\n\r\n# ---------------------------------------------------------------------------\r\n\r\nexport splitPrefix = (line) =>\r\n\r\n\tassert isString(line), \"non-string #{OL(line)}\"\r\n\tline = rtrim(line)\r\n\tlMatches = line.match(/^(\\s*)(.*)$/)\r\n\treturn [lMatches[1], lMatches[2]]\r\n\r\n# ---------------------------------------------------------------------------\r\n#   splitLine - separate a line into [level, line]\r\n\r\nexport splitLine = (line, oneIndent=undef) =>\r\n\r\n\t[prefix, str] = splitPrefix(line)\r\n\treturn [indentLevel(prefix, oneIndent), str]\r\n\r\n# ---------------------------------------------------------------------------\r\n#   indentLevel - determine indent level of a string\r\n#                 it's OK if the string is ONLY indentation\r\n\r\nexport indentLevel = (line, oneIndent=undef) =>\r\n\r\n\tassert isString(line), \"not a string\"\r\n\r\n\t# --- This will always match, and it's greedy\r\n\tif lMatches = line.match(/^\\s*/)\r\n\t\tprefix = lMatches[0]\r\n\t\tprefixLen = prefix.length\r\n\r\n\tif (prefixLen == 0)\r\n\t\treturn 0\r\n\r\n\t# --- Match \\t* followed by \\x20* (error if no match)\r\n\tif lMatches = prefix.match(/(\\t*)(\\x20*)/)\r\n\t\tnTabs = lMatches[1].length\r\n\t\tnSpaces = lMatches[2].length\r\n\telse\r\n\t\tcroak \"Invalid mix of TABs and spaces\"\r\n\r\n\t# --- oneIndent must be one of:\r\n\t#        undef\r\n\t#        a single TAB character\r\n\t#        some number of space characters\r\n\r\n\tswitch oneIndent\r\n\t\twhen undef\r\n\t\t\tif (nTabs > 0)\r\n\t\t\t\tlevel = nTabs     # there may also be spaces, but we ignore them\r\n\t\t\t\toneIndent = \"\\t\"  # may be used at end\r\n\t\t\telse\r\n\t\t\t\tassert (nSpaces > 0), \"There must be TABS or spaces\"\r\n\t\t\t\tlevel = 1\r\n\t\t\t\toneIndent = ' '.repeat(nSpaces) # may be used at end\r\n\t\twhen \"\\t\"\r\n\t\t\tassert (nTabs > 0), \"Expecting TAB indentation, found spaces\"\r\n\t\t\t# --- NOTE: there may be spaces, but they're not indentation\r\n\t\t\tlevel = nTabs\r\n\t\telse\r\n\t\t\t# --- oneIndent must be all space chars\r\n\t\t\tassert (nTabs == 0),\r\n\t\t\t\t\t\"Indentation has TABs but oneIndent = #{OL(oneIndent)}\"\r\n\t\t\tassert (nSpaces % oneIndent.length == 0),\r\n\t\t\t\t\"prefix #{OL(prefix)} not a mult of #{OL(oneIndent)}\"\r\n\t\t\tlevel = nSpaces / oneIndent.length\r\n\r\n\t# --- If a block, i.e. multi-line string, then all lines must be\r\n\t#     at least at this level\r\n\tif (line.indexOf(\"\\n\") >= 0)\r\n\t\tfor str in toArray(line)\r\n\t\t\tassert (indentLevel(str, oneIndent) >= level),\r\n\t\t\t\t\t\"indentLevel of #{OL(line)} can't be found\"\r\n\treturn level\r\n\r\n# ---------------------------------------------------------------------------\r\n#   indentation - return appropriate indentation string for given level\r\n#   export only to allow unit testing\r\n\r\nexport indentation = (level, oneIndent=\"\\t\") =>\r\n\r\n\tassert isInteger(level), \"Not an integer: #{OL(level)}\"\r\n\tassert (level >= 0), \"indentation(): negative level\"\r\n\treturn oneIndent.repeat(level)\r\n\r\n# ---------------------------------------------------------------------------\r\n#   isUndented - true iff indentLevel(line) == 0\r\n\r\nexport isUndented = (line) =>\r\n\r\n\tassert isString(line), \"non-string #{OL(line)}\"\r\n\treturn notdefined(line.match(/^\\s/))\r\n\r\n# ---------------------------------------------------------------------------\r\n#   indented - add indentation to each string in a block or array\r\n#            - returns the same type as input, i.e. array or string\r\n\r\nexport indented = (input, level=1, oneIndent=\"\\t\") =>\r\n\r\n\t# --- input must be either a string or array of strings\r\n\tassert isString(input) || isArrayOfStrings(input),\r\n\t\t\t\"invalid input: #{OL(input)}\"\r\n\r\n\t# --- oneIndent must be a string\r\n\tassert isString(oneIndent), \"Not a string: #{OL(oneIndent)}\"\r\n\r\n\t# --- level can be a string, in which case it is\r\n\t#     pre-pended to each line of input\r\n\tif isString(level)\r\n\t\tif (level == '')\r\n\t\t\treturn input\r\n\t\ttoAdd = level\r\n\telse if isInteger(level)\r\n\t\tif (level == 0)\r\n\t\t\treturn input\r\n\t\tassert (level > 0), \"Invalid level #{OL(level)}\"\r\n\t\ttoAdd = indentation(level, oneIndent)\r\n\telse\r\n\t\tcroak \"Invalid level #{OL(level)}\"\r\n\r\n\t# --- NOTE: toArray(input) just returns input if it's an array\r\n\t#           else it splits the string into an array of lines\r\n\tlLines = []\r\n\tfor line in toArray(input)\r\n\t\tif isEmpty(line)\r\n\t\t\tlLines.push ''\r\n\t\telse\r\n\t\t\tlLines.push \"#{toAdd}#{line}\"\r\n\r\n\tif isArray(input)\r\n\t\treturn lLines\r\n\telse if isString(input)\r\n\t\treturn toBlock(lLines)\r\n\tcroak \"Invalid input; #{OL(input)}\"\r\n\r\n# ---------------------------------------------------------------------------\r\n#   undented - string with 1st line indentation removed for each line\r\n#            - ignore leading empty lines\r\n#            - returns same type as text, i.e. either string or array\r\n\r\nexport undented = (input) =>\r\n\r\n\t# --- If a string, convert to an array\r\n\tif isString(input)\r\n\t\tlLines = toArray(input)\r\n\telse if isArray(input)\r\n\t\tlLines = input\r\n\telse\r\n\t\tcroak \"input not a string or array\"\r\n\r\n\t# --- Remove leading blank lines\r\n\twhile (lLines.length > 0) && isEmpty(lLines[0])\r\n\t\tlLines.shift()   # remove\r\n\r\n\tif (lLines.length == 0)\r\n\t\tif isString(input)\r\n\t\t\treturn ''\r\n\t\telse\r\n\t\t\treturn []\r\n\r\n\t# --- determine what to remove from beginning of each line\r\n\tlMatches = lLines[0].match(/^\\s*/)\r\n\ttoRemove = lMatches[0]\r\n\tnToRemove = toRemove.length\r\n\tif (nToRemove > 0)\r\n\t\tlLines = lLines.map( (line) =>\r\n\t\t\tif isEmpty(line)\r\n\t\t\t\treturn ''\r\n\t\t\telse\r\n\t\t\t\tassert (line.indexOf(toRemove)==0),\r\n\t\t\t\t\t\"can't remove #{OL(toRemove)} from #{OL(line)}\"\r\n\t\t\t\treturn line.substr(nToRemove)\r\n\t\t\t)\r\n\r\n\tif isString(input)\r\n\t\treturn toBlock(lLines)\r\n\telse\r\n\t\treturn lLines\r\n\r\n# ---------------------------------------------------------------------------\r\n#    enclose - indent text, surround with pre and post\r\n\r\nexport enclose = (text, pre, post, oneIndent=\"\\t\") =>\r\n\r\n\treturn toBlock([\r\n\t\tpre\r\n\t\tindented(text, 1, oneIndent)\r\n\t\tpost\r\n\t\t])\r\n"
  ]
}