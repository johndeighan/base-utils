{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "src\\lib\\indent.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# indent.coffee\n\nimport {\n\tundef, defined, notdefined, toArray, toBlock, OL, rtrim,\n\tisInteger, isString, isArray, isEmpty, isArrayOfStrings,\n\t} from '@jdeighan/base-utils'\nimport {assert, croak} from '@jdeighan/base-utils/exceptions'\n\n# ---------------------------------------------------------------------------\n\nexport getOneIndent = (str) =>\n\n\tif (lMatches = str.match(/^\\t+(?:\\S|$)/))\n\t\treturn \"\\t\"\n\telse if (lMatches = str.match(/^(\\x20+)(?:\\S|$)/))   # space char\n\t\treturn lMatches[1]\n\tassert notdefined(str.match(/^\\s/)), \"Mixed indentation types\"\n\treturn undef\n\n# ---------------------------------------------------------------------------\n\nexport splitPrefix = (line) =>\n\n\tassert isString(line), \"non-string #{OL(line)}\"\n\tline = rtrim(line)\n\tlMatches = line.match(/^(\\s*)(.*)$/)\n\treturn [lMatches[1], lMatches[2]]\n\n# ---------------------------------------------------------------------------\n#   splitLine - separate a line into [level, line]\n\nexport splitLine = (line, oneIndent=undef) =>\n\n\t[prefix, str] = splitPrefix(line)\n\treturn [indentLevel(prefix, oneIndent), str]\n\n# ---------------------------------------------------------------------------\n#   indentLevel - determine indent level of a string\n#                 it's OK if the string is ONLY indentation\n\nexport indentLevel = (line, oneIndent=undef) =>\n\n\tassert isString(line), \"not a string: #{OL(line)}\"\n\n\t# --- This will always match, and it's greedy\n\tif lMatches = line.match(/^\\s*/)\n\t\tprefix = lMatches[0]\n\t\tprefixLen = prefix.length\n\n\tif (prefixLen == 0)\n\t\treturn 0\n\n\t# --- Match \\t* followed by \\x20* (error if no match)\n\tif lMatches = prefix.match(/(\\t*)(\\x20*)/)\n\t\tnTabs = lMatches[1].length\n\t\tnSpaces = lMatches[2].length\n\telse\n\t\tcroak \"Invalid mix of TABs and spaces\"\n\n\t# --- oneIndent must be one of:\n\t#        undef\n\t#        a single TAB character\n\t#        some number of space characters\n\n\tswitch oneIndent\n\t\twhen undef\n\t\t\tif (nTabs > 0)\n\t\t\t\tlevel = nTabs     # there may also be spaces, but we ignore them\n\t\t\t\toneIndent = \"\\t\"  # may be used at end\n\t\t\telse\n\t\t\t\tassert (nSpaces > 0),\n\t\t\t\t\t\t\"There must be TABS or spaces in #{OL(line)}\"\n\t\t\t\tlevel = 1\n\t\t\t\toneIndent = ' '.repeat(nSpaces) # may be used at end\n\t\twhen \"\\t\"\n\t\t\tassert (nTabs > 0), \"Expecting TAB indentation, found spaces\"\n\t\t\t# --- NOTE: there may be spaces, but they're not indentation\n\t\t\tlevel = nTabs\n\t\telse\n\t\t\t# --- oneIndent must be all space chars\n\t\t\tassert (nTabs == 0),\n\t\t\t\t\t\"Indentation has TABs but oneIndent = #{OL(oneIndent)}\"\n\t\t\tassert (nSpaces % oneIndent.length == 0),\n\t\t\t\t\"prefix #{OL(prefix)} not a mult of #{OL(oneIndent)}\"\n\t\t\tlevel = nSpaces / oneIndent.length\n\n\t# --- If a block, i.e. multi-line string, then all lines must be\n\t#     at least at this level\n\tif (line.indexOf(\"\\n\") >= 0)\n\t\tfor str in toArray(line)\n\t\t\tassert (indentLevel(str, oneIndent) >= level),\n\t\t\t\t\t\"indentLevel of #{OL(line)} can't be found\"\n\treturn level\n\n# ---------------------------------------------------------------------------\n#   indentation - return appropriate indentation string for given level\n#   export only to allow unit testing\n\nexport indentation = (level, oneIndent=\"\\t\") =>\n\n\tassert isInteger(level), \"Not an integer: #{OL(level)}\"\n\tassert (level >= 0), \"indentation(): negative level\"\n\treturn oneIndent.repeat(level)\n\n# ---------------------------------------------------------------------------\n#   isIndented - true iff indentLevel(line) > 0\n\nexport isIndented = (line) =>\n\n\treturn defined(line) && defined(line.match(/^\\s/))\n\n# ---------------------------------------------------------------------------\n#   isUndented - true iff indentLevel(line) == 0\n\nexport isUndented = (line) =>\n\n\treturn defined(line) && notdefined(line.match(/^\\s/))\n\n# ---------------------------------------------------------------------------\n#   indented - add indentation to each string in a block or array\n#            - returns the same type as input, i.e. array or string\n\nexport indented = (input, level=1, oneIndent=\"\\t\") =>\n\n\t# --- input must be either a string or array of strings\n\tassert isString(input) || isArrayOfStrings(input),\n\t\t\t\"invalid input: #{OL(input)}\"\n\n\t# --- oneIndent must be a string\n\tassert isString(oneIndent), \"Not a string: #{OL(oneIndent)}\"\n\n\t# --- level can be a string, in which case it is\n\t#     pre-pended to each line of input\n\tif isString(level)\n\t\tif (level == '')\n\t\t\treturn input\n\t\ttoAdd = level\n\telse if isInteger(level)\n\t\tif (level == 0)\n\t\t\treturn input\n\t\tassert (level > 0), \"Invalid level #{OL(level)}\"\n\t\ttoAdd = indentation(level, oneIndent)\n\telse\n\t\tcroak \"Invalid level #{OL(level)}\"\n\n\t# --- NOTE: toArray(input) just returns input if it's an array\n\t#           else it splits the string into an array of lines\n\tlLines = []\n\tfor line in toArray(input)\n\t\tif isEmpty(line)\n\t\t\tlLines.push ''\n\t\telse\n\t\t\tlLines.push \"#{toAdd}#{line}\"\n\n\tif isArray(input)\n\t\treturn lLines\n\telse if isString(input)\n\t\treturn toBlock(lLines)\n\tcroak \"Invalid input; #{OL(input)}\"\n\n# ---------------------------------------------------------------------------\n#   undented - string with 1st line indentation removed for each line\n#            - ignore leading empty lines\n#            - returns same type as text, i.e. either string or array\n\nexport undented = (input) =>\n\n\t# --- If a string, convert to an array\n\tif isString(input)\n\t\tlLines = toArray(input)\n\telse if isArray(input)\n\t\tlLines = input\n\telse\n\t\tcroak \"input not a string or array\"\n\n\t# --- Remove leading blank lines\n\twhile (lLines.length > 0) && isEmpty(lLines[0])\n\t\tlLines.shift()   # remove\n\n\tif (lLines.length == 0)\n\t\tif isString(input)\n\t\t\treturn ''\n\t\telse\n\t\t\treturn []\n\n\t# --- determine what to remove from beginning of each line\n\tlMatches = lLines[0].match(/^\\s*/)\n\ttoRemove = lMatches[0]\n\tnToRemove = toRemove.length\n\tif (nToRemove > 0)\n\t\tlLines = lLines.map( (line) =>\n\t\t\tif isEmpty(line)\n\t\t\t\treturn ''\n\t\t\telse\n\t\t\t\tassert (line.indexOf(toRemove)==0),\n\t\t\t\t\t\"can't remove #{OL(toRemove)} from #{OL(line)}\"\n\t\t\t\treturn line.substr(nToRemove)\n\t\t\t)\n\n\tif isString(input)\n\t\treturn toBlock(lLines)\n\telse\n\t\treturn lLines\n\n# ---------------------------------------------------------------------------\n#    enclose - indent text, surround with pre and post\n\nexport enclose = (text, pre, post, oneIndent=\"\\t\") =>\n\n\treturn toBlock([\n\t\tpre\n\t\tindented(text, 1, oneIndent)\n\t\tpost\n\t\t])"
  ]
}